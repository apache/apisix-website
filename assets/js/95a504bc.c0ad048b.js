"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[6877],{35318:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var a=n(27378);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),o=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=o(e.components);return a.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=o(n),d=r,h=m["".concat(c,".").concat(d)]||m[d]||u[d]||i;return n?a.createElement(h,s(s({ref:t},p),{},{components:n})):a.createElement(h,s({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=m;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,s[1]=l;for(var o=2;o<i;o++)s[o]=n[o];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},74639:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>o});var a=n(25773),r=(n(27378),n(35318));const i={title:"mTLS everywhere",authors:[{name:"Nicolas Fr\xe4nkel",title:"Author",url:"https://github.com/nfrankel",image_url:"https://avatars.githubusercontent.com/u/752258"}],keywords:["Security","TLS","DevOps","cert-manager"],description:"Security in one's information system has always been among the most critical Non-Functional Requirements. Transport Secure Layer, aka TLS, formerly SSL, is among its many pillars. In this post, I'll show how to configure TLS for Apache APISIX.\n",tags:["Ecosystem"],image:"https://static.apiseven.com/uploads/2023/06/08/JXRmK9nZ_keys.jpeg"},s=void 0,l={permalink:"/blog/2023/03/23/mtls-everywhere",source:"@site/blog/2023/03/23/mtls-everywhere.md",title:"mTLS everywhere",description:"Security in one's information system has always been among the most critical Non-Functional Requirements. Transport Secure Layer, aka TLS, formerly SSL, is among its many pillars. In this post, I'll show how to configure TLS for Apache APISIX.\n",date:"2023-03-23T00:00:00.000Z",formattedDate:"March 23, 2023",tags:[{label:"Ecosystem",permalink:"/blog/tags/ecosystem"}],readingTime:12.435,truncated:!0,authors:[{name:"Nicolas Fr\xe4nkel",title:"Author",url:"https://github.com/nfrankel",image_url:"https://avatars.githubusercontent.com/u/752258",imageURL:"https://avatars.githubusercontent.com/u/752258"}],prevItem:{title:"Biweekly Report (Mar 13 - Mar 26)",permalink:"/blog/2023/03/30/weekly-report-0330"},nextItem:{title:"Biweekly Report (Feb 27 - Mar 12)",permalink:"/blog/2023/03/17/weekly-report-0312"}},c={authorsImageUrls:[void 0]},o=[{value:"TLS in a few words",id:"tls-in-a-few-words",children:[],level:2},{value:"Generating certificates with cert-manager",id:"generating-certificates-with-cert-manager",children:[],level:2},{value:"Quick overview of a sample Apache APISIX architecture",id:"quick-overview-of-a-sample-apache-apisix-architecture",children:[],level:2},{value:"cert-manager&#39;s Certificates",id:"cert-managers-certificates",children:[],level:2},{value:"Configuring mTLS between etcd and APISIX",id:"configuring-mtls-between-etcd-and-apisix",children:[],level:2},{value:"Client access",id:"client-access",children:[],level:2},{value:"TLS with upstreams",id:"tls-with-upstreams",children:[],level:2},{value:"Conclusion",id:"conclusion",children:[],level:2}],p={toc:o};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Security in one's information system has always been among the most critical Non-Functional Requirements. Transport Secure Layer, ",(0,r.kt)("em",{parentName:"p"},"aka")," TLS, formerly SSL, is among its many pillars. In this post, I'll show how to configure TLS for ",(0,r.kt)("a",{parentName:"p",href:"https://apisix.apache.org/"},"Apache APISIX"),".")),(0,r.kt)("head",null,(0,r.kt)("link",{rel:"canonical",href:"https://blog.frankel.ch/mtls-everywhere/"})),(0,r.kt)("h2",{id:"tls-in-a-few-words"},"TLS in a few words"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://wikipedia.org/wiki/Transport_Layer_Security"},"TLS")," offers several capabilities:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Server authentication: the client is confident that the server it exchanges data with is the right one. It avoids sending data, which might be confidential, to the wrong actor"),(0,r.kt)("li",{parentName:"ul"},"Optional client authentication: the other way around, the server only allows clients whose identity can be verified"),(0,r.kt)("li",{parentName:"ul"},"Confidentiality: no third party can read the data exchanged between the client and the server"),(0,r.kt)("li",{parentName:"ul"},"Integrity: no third party can tamper with the data")),(0,r.kt)("p",null,"TLS works through certificates. A certificate is similar to an ID, proving the certificate's holder identity. Just like an ID, you need to trust who delivered it. Trust is established through a chain: if I trust Alice, who trusts Bob, who in turn trusts Charlie, who delivered the certificate, then I trust the latter. In this scenario, Alice is known as the ",(0,r.kt)("strong",{parentName:"p"},"root certificate authority"),"."),(0,r.kt)("p",null,"TLS authentication is based on public key cryptography. Alice generates a public key/private key pair and publishes the public key. If one encrypts data with the public key, only the private key that generated the public key can decrypt them. The other usage is for one to encrypt data with the private key and everybody with the public key to decrypt it, thus proving their identity."),(0,r.kt)("p",null,"Finally, mutual TLS, ",(0,r.kt)("em",{parentName:"p"},"aka")," mTLS, is the configuration of two-way TLS: server authentication to the client, as usual, but also the other way around, client authentication to the server."),(0,r.kt)("p",null,"We now have enough understanding of the concepts to get our hands dirty."),(0,r.kt)("h2",{id:"generating-certificates-with-cert-manager"},"Generating certificates with cert-manager"),(0,r.kt)("p",null,"A couple of root ",(0,r.kt)("abbr",{title:"Certificate Authority"},"CA")," are installed in browsers by default. That's how we can browse HTTPS websites safely, trusting that ",(0,r.kt)("a",{parentName:"p",href:"https://apache.org"},"https://apache.org")," is the site they pretend to be. The infrastructure has no pre-installed certificates, so we must start from scratch."),(0,r.kt)("p",null,"We need at least one root certificate. In turn, it will generate all other certificates. While it's possible to do every manually, I'll rely on ",(0,r.kt)("a",{parentName:"p",href:"https://cert-manager.io/"},"cert-manager")," in Kubernetes. As its name implies, cert-manager is a solution to manage certificates."),(0,r.kt)("p",null,"Installing it with Helm is straightforward:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"helm repo add jetstack https://charts.jetstack.io  #1\n\nhelm install \\\n  cert-manager jetstack/cert-manager \\\n  --namespace cert-manager \\                       #2\n  --create-namespace \\                             #2\n  --version v1.11.0 \\\n  --set installCRDs=true \\\n  --set prometheus.enabled=false                   #3\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Add the charts' repository"),(0,r.kt)("li",{parentName:"ol"},"Install the objects in a dedicated namespace"),(0,r.kt)("li",{parentName:"ol"},"Don't monitor, in the scope of this post")),(0,r.kt)("p",null,"We can make sure that everything works as expected by looking at the pods:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pods -n cert-manager\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"cert-manager-cainjector-7f694c4c58-fc9bk  1/1  Running  2  (2d1h ago)  7d\ncert-manager-cc4b776cf-8p2t8              1/1  Running  1  (2d1h ago)  7d\ncert-manager-webhook-7cd8c769bb-494tl     1/1  Running  1  (2d1h ago)  7d\n")),(0,r.kt)("p",null,"cert-manager can sign certificates from multiple sources: HashiCorp Vault, Let's Encrypt, etc. To keep things simple:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"We will generate our dedicated root certificate, ",(0,r.kt)("em",{parentName:"li"},"i.e."),", ",(0,r.kt)("inlineCode",{parentName:"li"},"Self-Signed")),(0,r.kt)("li",{parentName:"ul"},"We won't handle certificates rotation")),(0,r.kt)("p",null,"Let's start with the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: cert-manager.io/v1\nkind: ClusterIssuer                           #1\nmetadata:\n  name: selfsigned-issuer\nspec:\n  selfSigned: {}\n---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: tls                                   #2\n---\napiVersion: cert-manager.io/v1\nkind: Certificate                             #3\nmetadata:\n  name: selfsigned-ca\n  namespace: tls\nspec:\n  isCA: true\n  commonName: selfsigned-ca\n  secretName: root-secret\n  issuerRef:\n    name: selfsigned-issuer\n    kind: ClusterIssuer\n    group: cert-manager.io\n---\napiVersion: cert-manager.io/v1\nkind: Issuer                                  #4\nmetadata:\n  name: ca-issuer\n  namespace: tls\nspec:\n  ca:\n    secretName: root-secret\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Certificate authority that generates certificates ",(0,r.kt)("strong",{parentName:"li"},"cluster-wide")),(0,r.kt)("li",{parentName:"ol"},"Create a namespace for our demo"),(0,r.kt)("li",{parentName:"ol"},"Namespaced root certificate using the cluster-wide issuer. Only used to create a namespaced issuer"),(0,r.kt)("li",{parentName:"ol"},"Namespaced issuer. Used to create all other certificates in the post")),(0,r.kt)("p",null,"After applying the previous manifest, we should be able to see the single certificate that we created:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get certificate -n tls\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"NAME            READY   SECRET        AGE\nselfsigned-ca   True    root-secret   7s\n")),(0,r.kt)("p",null,"The certificate infrastructure is ready; let's look at Apache APISIX."),(0,r.kt)("h2",{id:"quick-overview-of-a-sample-apache-apisix-architecture"},"Quick overview of a sample Apache APISIX architecture"),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://apisix.apache.org/"},"Apache APISIX")," is an API Gateway. By default, it stores its configuration in ",(0,r.kt)("a",{parentName:"p",href:"https://etcd.io/"},"etcd"),", a distributed key-value store - the same one used by Kubernetes. Note that in real-world scenarios, we should set up etcd clustering to improve the resiliency of the solution. For this post, we will limit ourselves to a single etcd instance. Apache APISIX offers an admin API via HTTP endpoints. Finally, the gateway forwards calls from the client to an upstream. Here's an overview of the architecture and the required certificates:"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://static.apiseven.com/uploads/2023/06/08/dplOhFAt_apisix-architecture.svg",alt:"Apache APISIX architecture"})),(0,r.kt)("p",null,"Let's start with the foundational bricks: etcd and Apache APISIX. We need two certificates: one for etcd, in the server role, and one for Apache APISIX, as the etcd client."),(0,r.kt)("p",null,"Let's set up certificates from our namespaced issuer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\n  name: etcd-server                         #1\n  namespace: tls\nspec:\n  secretName: etcd-secret                   #2\n  isCA: false\n  usages:\n    - client auth                           #3\n    - server auth                           #3\n  dnsNames:\n    - etcd                                  #4\n  issuerRef:\n    name: ca-issuer                         #5\n    kind: Issuer\n---\napiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\n  name: apisix-client                       #6\n  namespace: tls\nspec:\n  secretName: apisix-client-secret\n  isCA: false\n  usages:\n    - client auth\n  emailAddresses:\n    - apisix@apache.org                     #7\n  issuerRef:\n    name: ca-issuer                         #5\n    kind: Issuer\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Certificate for etcd"),(0,r.kt)("li",{parentName:"ol"},"Kubernetes ",(0,r.kt)("inlineCode",{parentName:"li"},"Secret")," name, see below"),(0,r.kt)("li",{parentName:"ol"},"Usages for this certificate"),(0,r.kt)("li",{parentName:"ol"},"Kubernetes ",(0,r.kt)("inlineCode",{parentName:"li"},"Service")," name, see below"),(0,r.kt)("li",{parentName:"ol"},"Reference the previously namespaced issuer created earlier"),(0,r.kt)("li",{parentName:"ol"},"Certificate for Apache APISIX as a client of etcd"),(0,r.kt)("li",{parentName:"ol"},"Mandatory attribute for clients")),(0,r.kt)("p",null,"After applying the above manifest, we can list the certificates in the ",(0,r.kt)("inlineCode",{parentName:"p"},"tls")," namespace:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get certificates -n tls\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"NAME              READY   SECRET                 AGE\nselfsigned-ca     True    root-secret            8m59s    //1\napisix-client     True    apisix-client-secret   8m22s    //2\netcd-server       True    etcd-secret            8m54s    //2\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Previously created certificate"),(0,r.kt)("li",{parentName:"ol"},"Newly-created certificates signed by ",(0,r.kt)("inlineCode",{parentName:"li"},"selfsigned-ca"))),(0,r.kt)("h2",{id:"cert-managers-certificates"},"cert-manager's Certificates"),(0,r.kt)("p",null,"So far, we have created ",(0,r.kt)("inlineCode",{parentName:"p"},"Certificate")," objects, but we didn't explain what they are. Indeed, they are simple Kubernetes ",(0,r.kt)("abbr",{title:"Custom Resource Definition"},"CRD"),"s provided by cert-manager. Under the cover, cert-manager creates a Kubernetes ",(0,r.kt)("inlineCode",{parentName:"p"},"Secret")," from a ",(0,r.kt)("inlineCode",{parentName:"p"},"Certificate"),". It manages the whole lifecycle, so deleting a ",(0,r.kt)("inlineCode",{parentName:"p"},"Certificate")," deletes the bounded ",(0,r.kt)("inlineCode",{parentName:"p"},"Secret"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"secretName")," attribute in the above manifest sets the ",(0,r.kt)("inlineCode",{parentName:"p"},"Secret")," name."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get secrets -n tls\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"NAME                   TYPE                DATA   AGE\napisix-client-secret   kubernetes.io/tls   3      35m\netcd-secret            kubernetes.io/tls   3      35m\nroot-secret            kubernetes.io/tls   3      35m\n")),(0,r.kt)("p",null,"Let's look at a ",(0,r.kt)("inlineCode",{parentName:"p"},"Secret"),", ",(0,r.kt)("em",{parentName:"p"},"e.g."),", ",(0,r.kt)("inlineCode",{parentName:"p"},"apisix-client-secret"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl describe apisix-client-secret -n tls\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"Name:         apisix-client-secret\nNamespace:    tls\nLabels:       controller.cert-manager.io/fao=true\nAnnotations:  cert-manager.io/alt-names:\n              cert-manager.io/certificate-name: apisix-client\n              cert-manager.io/common-name:\n              cert-manager.io/ip-sans:\n              cert-manager.io/issuer-group:\n              cert-manager.io/issuer-kind: Issuer\n              cert-manager.io/issuer-name: ca-issuer\n              cert-manager.io/uri-sans:\n\nType:  kubernetes.io/tls\n\nData\n====\nca.crt:   1099 bytes\ntls.crt:  1115 bytes\ntls.key:  1679 bytes\n")),(0,r.kt)("p",null,"A ",(0,r.kt)("inlineCode",{parentName:"p"},"Secret")," created by a ",(0,r.kt)("inlineCode",{parentName:"p"},"Certificate")," provides three attributes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tls.crt"),": The certificate itself"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"tls.key"),": The private key"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ca.crt"),": The signing certificate in the certificate chain, ",(0,r.kt)("em",{parentName:"li"},"i.e."),", ",(0,r.kt)("inlineCode",{parentName:"li"},"root-secret/tls.crt"))),(0,r.kt)("p",null,"Kubernetes encodes ",(0,r.kt)("inlineCode",{parentName:"p"},"Secret")," content in base 64. To get any of the above in plain text, one should decode it, ",(0,r.kt)("em",{parentName:"p"},"e.g."),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get secret etcd-secret -n tls -o jsonpath='{ .data.tls\\.crt }' | base64\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"-----BEGIN CERTIFICATE-----\nMIIDBjCCAe6gAwIBAgIQM3JUR8+R0vuUndjGK/aOgzANBgkqhkiG9w0BAQsFADAY\nMRYwFAYDVQQDEw1zZWxmc2lnbmVkLWNhMB4XDTIzMDMxNjEwMTYyN1oXDTIzMDYx\nNDEwMTYyN1owADCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMQpMj/0\ngiDVOjOosSRRKUwTzl1Wo2R9YYAeteOW3fuMiAd+XaBGmRO/+GWZQN1tyRQ3pITM\nezBgogYAUUNcuqN/UAsgH/JM58niMjZdjRKn4+it94Nj1e24jFL4ts2snCn7FfKJ\n3zRtY9tyS7Agw3tCwtXV68Xpmf3CsfhPmn3rGdWHXyYctzAZhqYfEswN3hxpJZxR\nYVeb55WgDoPo5npZo3+yYiMtoOimIprcmZ2Ye8Wai9S4QKDafUWlvU5GQ65VVLzH\nPEdOMwbWcwiLqwUv889TiKiC5cyAD6wJOuPRF0KKxxFnG+lHlg9J2S1i5sC3pqoc\ni0pEQ+atOOyLMMECAwEAAaNkMGIwHQYDVR0lBBYwFAYIKwYBBQUHAwIGCCsGAQUF\nBwMBMAwGA1UdEwEB/wQCMAAwHwYDVR0jBBgwFoAU2ZaAdEficKUWPFRjdsKSEX/l\ngbMwEgYDVR0RAQH/BAgwBoIEZXRjZDANBgkqhkiG9w0BAQsFAAOCAQEABcNvYTm8\nZJe3jUq6f872dpNVulb2UvloTpWxQ8jwXgcrhekSKU6pZ4p9IPwfauHLjceMFJLp\nt2eDi5fSQ1upeqXOofeyKSYjjyA/aVf1zMI8ReCCQtQuAVYyJWBlNLc3XMMecbcp\nJLGtd/OAZnKDeYYkUX7cJ2wN6Wl/wGLM2lxsqDhEHEZwvGL0DmsdHw7hzSjdVmxs\n0Qgkh4jVbNUKdBok5U9Ivr3P1xDPaD/FqGFyM0ssVOCHxtPxhOUA/m3DSr6klfEF\nMcOfudZE958bChOrJgVrUnY3inR0J335bGQ1luEp5tYwPgyD9dG4MQEDD3oLwp+l\n+NtTUqz8WVlMxQ==\n-----END CERTIFICATE-----\n")),(0,r.kt)("h2",{id:"configuring-mtls-between-etcd-and-apisix"},"Configuring mTLS between etcd and APISIX"),(0,r.kt)("p",null,"With the certificates available, we can now configure mutual TLS between etcd and APISIX. Let's start with etcd:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: v1\nkind: Pod\nmetadata:\n  name: etcd\n  namespace: tls\n  labels:\n    role: config\nspec:\n  containers:\n    - name: etcd\n      image: bitnami/etcd:3.5.7\n      ports:\n        - containerPort: 2379\n      env:\n        - name: ETCD_TRUSTED_CA_FILE        #1\n          value: /etc/ssl/private/ca.crt\n        - name: ETCD_CERT_FILE              #2\n          value: /etc/ssl/private/tls.crt\n        - name: ETCD_KEY_FILE               #3\n          value: /etc/ssl/private/tls.key\n        - name: ETCD_ROOT_PASSWORD\n          value: whatever\n        - name: ETCD_CLIENT_CERT_AUTH       #4\n          value: "true"\n        - name: ETCD_LISTEN_CLIENT_URLS\n          value: https://0.0.0.0:2379\n      volumeMounts:\n        - name: ssl\n          mountPath: /etc/ssl/private       #5\n  volumes:\n    - name: ssl\n      secret:\n        secretName: etcd-secret             #5\n')),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Set the trusted CA"),(0,r.kt)("li",{parentName:"ol"},"Set the certificate"),(0,r.kt)("li",{parentName:"ol"},"Set the private key"),(0,r.kt)("li",{parentName:"ol"},"Require clients to pass their certificate, hence ensuring mutual authentication"),(0,r.kt)("li",{parentName:"ol"},"Mount the previously generated secret in the container for access")),(0,r.kt)("p",null,"Now, it's Apache APISIX's turn:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: ConfigMap                                            #1\nmetadata:\n  name: apisix-config\n  namespace: tls\ndata:\n  config.yaml: >-\n    apisix:\n      ssl:\n        ssl_trusted_certificate: /etc/ssl/certs/ca.crt     #2\n    deployment:\n      etcd:\n        host:\n          - https://etcd:2379\n        tls:\n          cert: /etc/ssl/certs/tls.crt                     #2\n          key: /etc/ssl/certs/tls.key                      #2\n      admin:\n        allow_admin:\n          - 0.0.0.0/0\n        https_admin: true                                  #3\n        admin_api_mtls:\n          admin_ssl_cert: /etc/ssl/private/tls.crt         #3\n          admin_ssl_cert_key: /etc/ssl/private/tls.key     #3\n          admin_ssl_ca_cert: /etc/ssl/private/ca.crt       #3\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: apisix\n  namespace: tls\n  labels:\n    role: gateway\nspec:\n  containers:\n    - name: apisix\n      image: apache/apisix:3.2.0-debian\n      ports:\n        - containerPort: 9443                              #4\n        - containerPort: 9180                              #5\n      volumeMounts:\n        - name: config                                      #1\n          mountPath: /usr/local/apisix/conf/config.yaml\n          subPath: config.yaml\n        - name: ssl                                        #6\n          mountPath: /etc/ssl/private\n        - name: etcd-client                                #7\n          mountPath: /etc/ssl/certs\n  volumes:\n    - name: config\n      configMap:\n        name: apisix-config\n    - name: ssl                                            #6,8\n      secret:\n        secretName: apisix-server-secret\n    - name: etcd-client                                    #7,8\n      secret:\n        secretName: apisix-client-secret\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Apache APISIX doesn't offer configuration via environment variables. We need to use a ",(0,r.kt)("inlineCode",{parentName:"li"},"ConfigMap")," that mirrors the regular ",(0,r.kt)("inlineCode",{parentName:"li"},"config.yaml")," file"),(0,r.kt)("li",{parentName:"ol"},"Configure ",(0,r.kt)("em",{parentName:"li"},"client")," authentication for etcd"),(0,r.kt)("li",{parentName:"ol"},"Configure ",(0,r.kt)("em",{parentName:"li"},"server")," authentication for the Admin API"),(0,r.kt)("li",{parentName:"ol"},"Regular HTTPS port"),(0,r.kt)("li",{parentName:"ol"},"Admin HTTPS port"),(0,r.kt)("li",{parentName:"ol"},"Certificates for server authentication"),(0,r.kt)("li",{parentName:"ol"},"Certificates for client authentication"),(0,r.kt)("li",{parentName:"ol"},"Two sets of certificates are used, one for server authentication for the Admin API and regular HTTPS, and one for client authentication for etcd.")),(0,r.kt)("p",null,"At this point, we can apply the above manifests and see the two pods communicating. When connecting, Apache APISIX sends its ",(0,r.kt)("inlineCode",{parentName:"p"},"apisix-client")," certificate via HTTPS. Because an authority signs the certificate that etcd trusts, it allows the connection."),(0,r.kt)("p",null,"I've omitted the ",(0,r.kt)("inlineCode",{parentName:"p"},"Service")," definition for brevity's sake, but you can check them in the associated ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ajavageek/tls-apisix"},"GitHub repo"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"NAME     READY   STATUS    RESTARTS   AGE\napisix   1/1     Running   0          179m\netcd     1/1     Running   0          179m\n")),(0,r.kt)("h2",{id:"client-access"},"Client access"),(0,r.kt)("p",null,"Now that we've set up the basic infrastructure, we should test accessing it with a client. We will use our faithful ",(0,r.kt)("inlineCode",{parentName:"p"},"curl"),", but any client that allows configuring certificates should work, ",(0,r.kt)("em",{parentName:"p"},"e.g"),", httpie."),(0,r.kt)("p",null,"The first step is to create a dedicated certificate-key pair for the client:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: cert-manager.io/v1\nkind: Certificate\nmetadata:\n  name: curl-client\n  namespace: tls\nspec:\n  secretName: curl-secret\n  isCA: false\n  usages:\n    - client auth\n  emailAddresses:\n    - curl@localhost.dev\n  issuerRef:\n    name: ca-issuer\n    kind: Issuer\n")),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"curl")," requires a path to the certificate file instead of the content. We can go around this limitation through the magic of zsh: the ",(0,r.kt)("inlineCode",{parentName:"p"},"=( ... )")," syntax allows the creation of a temporary file. If you're using another shell, you'll need to find the equivalent syntax or download the files manually."),(0,r.kt)("p",null,"Let's query the Admin API for all existing routes. This simple command allows checking that Apache APISIX is connected to etcd, and it can read its configuration from there."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"curl --resolve 'admin:32180:127.0.0.1' https://admin:32180/apisix/admin/routes \\                     #1\n     --cert =(kubectl get secret curl-secret -n tls -o jsonpath='{ .data.tls\\.crt }' | base64 -d) \\  #2\n     --key =(kubectl get secret curl-secret -n tls -o jsonpath='{ .data.tls\\.key }' | base64 -d) \\   #2\n     --cacert =(kubectl get secret curl-secret -n tls -o jsonpath='{ .data.ca\\.crt }' | base64 -d) \\ #2\n     -H 'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1'\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"--resolve")," avoids polluting one's ",(0,r.kt)("inlineCode",{parentName:"li"},"/etc/hosts")," file. ",(0,r.kt)("inlineCode",{parentName:"li"},"curl")," will translate ",(0,r.kt)("inlineCode",{parentName:"li"},"admin")," to ",(0,r.kt)("inlineCode",{parentName:"li"},"localhost"),", but the query is sent to ",(0,r.kt)("inlineCode",{parentName:"li"},"admin")," inside the Kubernetes cluster, thus using the correct ",(0,r.kt)("inlineCode",{parentName:"li"},"Service")),(0,r.kt)("li",{parentName:"ol"},"Get the required data inside the ",(0,r.kt)("inlineCode",{parentName:"li"},"Secret"),", decode it, and use it as a temporary file")),(0,r.kt)("p",null,"If everything works, and it should, the result should be the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{"total":0,"list":[]}\n')),(0,r.kt)("p",null,"No routes are available so far because we have yet to create any."),(0,r.kt)("h2",{id:"tls-with-upstreams"},"TLS with upstreams"),(0,r.kt)("p",null,"Last but not least, we should configure TLS for upstreams. In the following, I'll use a simple ",(0,r.kt)("a",{parentName:"p",href:"https://nginx.org/"},"nginx")," instance that responds with static content. Use it as an illustration for more complex upstreams."),(0,r.kt)("p",null,"The first step, as always, is to generate a dedicated ",(0,r.kt)("inlineCode",{parentName:"p"},"Certificate")," for the upstream. I'll skip how to do it as we already created a few. I call it ",(0,r.kt)("inlineCode",{parentName:"p"},"upstream-server")," and its ",(0,r.kt)("inlineCode",{parentName:"p"},"Secret"),", unimaginatively, ",(0,r.kt)("inlineCode",{parentName:"p"},"upstream-secret"),". We can now use the latter to secure nginx:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: ConfigMap                                           #1\nmetadata:\n  name: nginx-config\n  namespace: tls\ndata:\n  nginx.conf: >-\n    events {\n      worker_connections 1024;\n    }\n    http {\n      server {\n        listen              443 ssl;\n        server_name         upstream;\n        ssl_certificate     /etc/ssl/private/tls.crt;     #2\n        ssl_certificate_key /etc/ssl/private/tls.key;     #2\n\n        root /www/data;\n        location / {\n            index index.json;\n        }\n      }\n    }\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: upstream\n  namespace: tls\n  labels:\n    role: upstream\nspec:\n  containers:\n    - name: upstream\n      image: nginx:1.23-alpine\n      ports:\n        - containerPort: 443\n      volumeMounts:\n        - name: config\n          mountPath: /etc/nginx/nginx.conf                #1\n          subPath: nginx.conf\n        - name: content\n          mountPath: /www/data/index.json                 #3\n          subPath: index.json\n        - name: ssl                                       #2\n          mountPath: /etc/ssl/private\n  volumes:\n    - name: config\n      configMap:\n        name: nginx-config\n    - name: ssl                                           #2\n      secret:\n        secretName: upstream-secret\n    - name: content                                       #3\n      configMap:\n        name: nginx-content\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"nginx doesn't allow configuration via environment variables; we need to use the ",(0,r.kt)("inlineCode",{parentName:"li"},"ConfigMap")," approach"),(0,r.kt)("li",{parentName:"ol"},"Use the key-certificate pair created via the ",(0,r.kt)("inlineCode",{parentName:"li"},"Certificate")),(0,r.kt)("li",{parentName:"ol"},"Some static content unimportant in the scope of this post")),(0,r.kt)("p",null,"The next step is to create the route with the help of the Admin API. We prepared everything in the previous step; now we can use the API:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},'curl --resolve \'admin:32180:127.0.0.1\' https://admin:32180/apisix/admin/routes/1 \\\n     --cert =(kubectl get secret curl-secret -n tls -o jsonpath=\'{ .data.tls\\.crt }\' | base64 -d) \\     #1\n     --key =(kubectl get secret curl-secret -n tls -o jsonpath=\'{ .data.tls\\.key }\' | base64 -d) \\      #1\n     --cacert =(kubectl get secret curl-secret -n tls -o jsonpath=\'{ .data.ca\\.crt }\' | base64 -d) \\    #1\n     -H \'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\' -X PUT -i -d "{\n        \\"uri\\": \\"/\\",\n        \\"upstream\\": {\n          \\"scheme\\": \\"https\\",                                                                        #2\n          \\"nodes\\": {\n            \\"upstream:443\\": 1\n          },\n          \\"tls\\": {\n            \\"client_cert\\": \\"$(kubectl get secret curl-secret -n tls -o jsonpath=\'{ .data.tls\\.crt }\' | base64 -d)\\", #3\n            \\"client_key\\": \\"$(kubectl get secret curl-secret -n tls -o jsonpath=\'{ .data.tls\\.key }\' | base64 -d)\\"   #3\n          }\n        }\n     }"\n')),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Client auth for Admin API, as above"),(0,r.kt)("li",{parentName:"ol"},"Use HTTPS for the upstream"),(0,r.kt)("li",{parentName:"ol"},"Configure key-certificate pair for the route. Apache APISIX stores the data in etcd and will use them when you call the route. Alternatively, you can keep the pair as a dedicated object and use the newly-created reference (just like for upstreams). It depends on how many routes the certificate needs. For more information, check the ",(0,r.kt)("a",{parentName:"li",href:"https://apisix.apache.org/docs/apisix/admin-api/#ssl"},"SSL endpoint"))),(0,r.kt)("p",null,"Finally, we can check it works as expected:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"curl --resolve 'upstream:32443:127.0.0.1' https://upstream:32443/ \\\n     --cert =(kubectl get secret curl-secret -n tls -o jsonpath='{ .data.tls\\.crt }' | base64 -d) \\\n     --key =(kubectl get secret curl-secret -n tls -o jsonpath='{ .data.tls\\.key }' | base64 -d) \\\n     --cacert =(kubectl get secret curl-secret -n tls -o jsonpath='{ .data.ca\\.crt }' | base64 -d)\n")),(0,r.kt)("p",null,"And it does:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-json"},'{ "hello": "world" }\n')),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"In this post, I've described a working Apache APISIX architecture and implemented mutual TLS between all the components: etcd and APISIX, client and APISIX, and finally, client and upstream. I hope it will help you to achieve the same."),(0,r.kt)("p",null,"The complete source code for this post can be found on ",(0,r.kt)("a",{parentName:"p",href:"https//github.com/ajavageek/tls-apisix"},"GitHub"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"To go further:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://apisix.apache.org/blog/2021/12/15/deploy-apisix-in-kubernetes/"},"How to Easily Deploy Apache APISIX in Kubernetes")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://cert-manager.io/"},"cert-manager")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://medium.com/geekculture/a-simple-ca-setup-with-kubernetes-cert-manager-bc8ccbd9c2"},"A Simple CA Setup with Kubernetes Cert Manager")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://apisix.apache.org/docs/apisix/mtls/"},"Mutual TLS Authentication"))))}u.isMDXComponent=!0}}]);