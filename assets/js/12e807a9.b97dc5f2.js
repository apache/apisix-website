"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[16044],{35318:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>m});var n=a(27378);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},h=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),u=p(a),m=r,d=u["".concat(l,".").concat(m)]||u[m]||c[m]||i;return a?n.createElement(d,o(o({ref:t},h),{},{components:a})):n.createElement(d,o({ref:t},h))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var p=2;p<i;p++)o[p]=a[p];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},2028:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});var n=a(25773),r=(a(27378),a(35318));const i={title:"How Is Apache APISIX Fast?",authors:[{name:"API7.ai",title:"Author",url:"https://github.com/api7",image_url:"https://avatars.githubusercontent.com/u/61078451?s=200&v=4"}],keywords:["Apache APISIX","performance","API gateway","radix tree"],description:"Taking a look under Apache APISIX's hood to understand how it achieves ultimate performance.",tags:["Ecosystem"],image:"https://static.apiseven.com/uploads/2023/06/08/3LuvBVWL_apisix-fast-cover.png",canonical_url:"https://api7.ai/blog/how-is-apisix-fast"},o=void 0,s={permalink:"/blog/2023/06/12/how-is-apisix-fast",source:"@site/blog/2023/06/12/how-is-apisix-fast.md",title:"How Is Apache APISIX Fast?",description:"Taking a look under Apache APISIX's hood to understand how it achieves ultimate performance.",date:"2023-06-12T00:00:00.000Z",formattedDate:"June 12, 2023",tags:[{label:"Ecosystem",permalink:"/blog/tags/ecosystem"}],readingTime:6.04,truncated:!0,authors:[{name:"API7.ai",title:"Author",url:"https://github.com/api7",image_url:"https://avatars.githubusercontent.com/u/61078451?s=200&v=4",imageURL:"https://avatars.githubusercontent.com/u/61078451?s=200&v=4"}],prevItem:{title:"Biweekly Report (June 06 - June 18)",permalink:"/blog/2023/06/21/weekly-report-en"},nextItem:{title:"Biweekly Report (May 23 - June 5)",permalink:"/blog/2023/06/08/weekly-report"}},l={authorsImageUrls:[void 0]},p=[{value:"etcd as the Configuration Center",id:"etcd-as-the-configuration-center",children:[],level:2},{value:"Hash Tables for IP Addresses",id:"hash-tables-for-ip-addresses",children:[],level:2},{value:"Radix Trees for Routing",id:"radix-trees-for-routing",children:[],level:2},{value:"Look under the Hood",id:"look-under-the-hood",children:[],level:2}],h={toc:p};function c(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"In this article, we will look under the hood of APISIX and see what these are and how all of these work together to keep APISIX maintaining peak performance while handling significant traffic.")),(0,r.kt)("p",null,'"High speed," "minimum latency," and "ultimate performance" are often used to characterize ',(0,r.kt)("a",{parentName:"p",href:"https://api7.ai/apisix"},"Apache APISIX"),'. Even when someone asks me about APISIX, my answer always includes "high-performance cloud native API gateway."'),(0,r.kt)("p",null,"Performance benchmarks (vs. ",(0,r.kt)("a",{parentName:"p",href:"https://api7.ai/blog/apisix-kong-3-0-performance-comparison"},"Kong"),", ",(0,r.kt)("a",{parentName:"p",href:"https://apisix.apache.org/blog/2021/06/10/apache-apisix-and-envoy-performance-comparison/"},"Envoy"),") confirm these characteristics are indeed accurate (",(0,r.kt)("a",{parentName:"p",href:"https://github.com/api7/apisix-benchmark"},"test yourself"),")."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://static.apiseven.com/uploads/2023/06/08/L0HjyWGM_apisix-vs-kong-light.png",alt:"High speed, minimum latency, and ultimate performance"})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},(0,r.kt)("a",{parentName:"em",href:"https://github.com/api7/apisix-benchmark"},"Tests run")," for 10 rounds with 5000 unique routes on Standard D8s v3 (8 vCPUs, 32 GiB memory).")),(0,r.kt)("p",null,"But how does APISIX achieve this?"),(0,r.kt)("p",null,"To answer that question, we must look at three things: etcd, hash tables, and radix trees."),(0,r.kt)("p",null,"In this article, we will look under the hood of APISIX and see what these are and how all of these work together to keep APISIX maintaining peak performance while handling significant traffic."),(0,r.kt)("h2",{id:"etcd-as-the-configuration-center"},"etcd as the Configuration Center"),(0,r.kt)("p",null,"APISIX uses ",(0,r.kt)("a",{parentName:"p",href:"https://etcd.io/"},"etcd")," to store and synchronize configurations."),(0,r.kt)("p",null,"etcd is designed to work as a key-value store for configurations of large-scale distributed systems. APISIX is intended to be distributed and highly scalable from the ground up, and using etcd over traditional databases facilitates that."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://static.apiseven.com/uploads/2023/06/12/wjH9wJfU_architecture.png",alt:"APISIX architecture"})),(0,r.kt)("p",null,"Another key indispensable feature for API gateways is to be highly available, avoiding downtime and data loss. You can efficiently achieve this by deploying multiple instances of etcd to ensure a fault-tolerant, cloud native architecture."),(0,r.kt)("p",null,"APISIX can read/write configurations from/to etcd with minimum latency. Changes to the configuration files are notified instantly, allowing APISIX to monitor only the etcd updates instead of polling a database frequently, which can add performance overhead."),(0,r.kt)("p",null,"This ",(0,r.kt)("a",{parentName:"p",href:"https://etcd.io/docs/v3.5/learning/why/#comparison-chart"},"chart")," summarizes how etcd compares with other databases."),(0,r.kt)("h2",{id:"hash-tables-for-ip-addresses"},"Hash Tables for IP Addresses"),(0,r.kt)("p",null,"IP address-based allowlists/denylists are a common use case for API gateways."),(0,r.kt)("p",null,"To achieve high performance, APISIX stores the list of IP addresses in a hash table and uses it for matching (O(1)) than iterating through the list (O(N))."),(0,r.kt)("p",null,"As the number of IP addresses in the list increases, the performance impact of using hash tables for storage and matching becomes apparent."),(0,r.kt)("p",null,"Under the hood, APISIX uses the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/api7/lua-resty-ipmatcher"},"lua-resty-ipmatcher")," library to implement this functionality. The example below shows how the library is used:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local ipmatcher = require("resty.ipmatcher")\nlocal ip = ipmatcher.new({\n    "162.168.46.72",\n    "17.172.224.47",\n    "216.58.32.170",\n})\n\nngx.say(ip:match("17.172.224.47")) -- true\nngx.say(ip:match("176.24.76.126")) -- false\n')),(0,r.kt)("p",null,"The library uses Lua tables which are hash tables. The IP addresses are hashed and stored as indices in a table, and to search for a given IP address, you just have to index the table and test whether it is nil or not."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://static.apiseven.com/uploads/2023/06/12/5N5UFBWG_hash-table.png",alt:"Storing IP addresses in a hash table"})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"To search for an IP address, it first computes the hash (index) and checks its value. If it is non-empty, we have a match. This is done in constant time O(1).")),(0,r.kt)("h2",{id:"radix-trees-for-routing"},"Radix Trees for Routing"),(0,r.kt)("p",null,"Please forgive me for tricking you into a data structures lesson! But hear me out; this is where it gets interesting."),(0,r.kt)("p",null,"A key area where APISIX optimizes performance is route matching."),(0,r.kt)("p",null,"APISIX matches a route with a request from its URI, HTTP methods, host, and other information (see ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/apache/apisix/blob/98e56716fdf76b97c90531cac24de811d841c296/conf/config-default.yaml#L77"},"router"),"). And this needs to be efficient."),(0,r.kt)("p",null,"If you have read the previous section, an obvious answer would be to use a hash algorithm. But route matching is tricky because multiple requests can match the same route."),(0,r.kt)("p",null,"For example, if we have a route ",(0,r.kt)("inlineCode",{parentName:"p"},"/api/*"),", then both ",(0,r.kt)("inlineCode",{parentName:"p"},"/api/create")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"/api/destroy")," must match the route. But this is not possible with a hash algorithm."),(0,r.kt)("p",null,"Regular expressions can be an alternate solution. Routes can be configured in a regex, and it can match multiple requests without the need to hardcode each request."),(0,r.kt)("p",null,"If we take our previous example, we can use the regex ",(0,r.kt)("inlineCode",{parentName:"p"},"/api/[A-Za-z0-9]+")," to match both ",(0,r.kt)("inlineCode",{parentName:"p"},"/api/create")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"/api/destroy"),". More complex regexes could match more complex routes."),(0,r.kt)("p",null,"But regex is slow! And we know APISIX is fast. So instead, APISIX uses radix trees which are compressed prefix trees (trie) that work really well for fast lookups."),(0,r.kt)("p",null,"Let's look at a simple example. Suppose we have the following words:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"romane"),(0,r.kt)("li",{parentName:"ul"},"romanus"),(0,r.kt)("li",{parentName:"ul"},"romulus"),(0,r.kt)("li",{parentName:"ul"},"rubens"),(0,r.kt)("li",{parentName:"ul"},"ruber"),(0,r.kt)("li",{parentName:"ul"},"rubicon"),(0,r.kt)("li",{parentName:"ul"},"rubicundus")),(0,r.kt)("p",null,"A prefix tree would store it like this:"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://static.apiseven.com/uploads/2023/06/12/wDoV1tl6_prefix-tree.png",alt:"Prefix tree"})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},'The highlighted traversal shows the word "rubens."')),(0,r.kt)("p",null,"A radix tree optimizes a prefix tree by merging child nodes if a node only has one child node. Our example trie would look like this as a radix tree:"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://static.apiseven.com/uploads/2023/06/12/ePG0v1sB_radix-tree.png",alt:"Radix tree"})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},'The highlighted traversal still shows the word "rubens." But the tree looks much smaller!')),(0,r.kt)("p",null,"When you ",(0,r.kt)("a",{parentName:"p",href:"https://docs.api7.ai/apisix/getting-started/configure-routes"},"create routes in APISIX"),", APISIX stores them in these trees."),(0,r.kt)("p",null,"APISIX can then work flawlessly because the time it takes to match a route only depends on the length of the URI in the request and is independent of the number of routes (O(K), K is the length of the key/URI)."),(0,r.kt)("p",null,"So APISIX will be as quick as it is when matching 10 routes when you first start out and 5000 routes when you scale."),(0,r.kt)("p",null,"This crude example shows how APISIX can store and match routes using radix trees:"),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://static.apiseven.com/uploads/2023/06/12/eiOwAjNu_apisix-route-matching.png",alt:"Crude example of route matching in APISIX"})),(0,r.kt)("p",null,(0,r.kt)("em",{parentName:"p"},"The highlighted traversal shows the route ",(0,r.kt)("inlineCode",{parentName:"em"},"/user/*")," where the ",(0,r.kt)("inlineCode",{parentName:"em"},"*")," represents a prefix. So a URI like ",(0,r.kt)("inlineCode",{parentName:"em"},"/user/navendu")," will match this route. The example code below should give more clarity to these ideas.")),(0,r.kt)("p",null,"APISIX uses the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/api7/lua-resty-radixtree"},"lua-resty-radixtree")," library, which wraps around ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/antirez/rax"},"rax"),", a radix tree implementation in C. This improves the performance compared to implementing the library in pure Lua."),(0,r.kt)("p",null,"The example below shows how the library is used:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local radix = require("resty.radixtree")\nlocal rx = radix.new({\n    {\n        paths = { "/api/*action" },\n        metadata = { "metadata /api/action" }\n    },\n    {\n        paths = { "/user/:name" },\n        metadata = { "metadata /user/name" },\n        methods = { "GET" },\n    },\n    {\n        paths = { "/admin/:name" },\n        metadata = { "metadata /admin/name" },\n        methods = { "GET", "POST", "PUT" },\n        filter_fun = function(vars, opts)\n            return vars["arg_access"] == "admin"\n        end\n    }\n})\n\nlocal opts = {\n    matched = {}\n}\n\n-- matches the first route\nngx.say(rx:match("/api/create", opts)) -- metadata /api/action\nngx.say("action: ", opts.matched.action) -- action: create\n\nngx.say(rx:match("/api/destroy", opts)) -- metadata /api/action\nngx.say("action: ", opts.matched.action) -- action: destroy\n\nlocal opts = {\n    method = "GET",\n    matched = {}\n}\n\n-- matches the second route\nngx.say(rx:match("/user/bobur", opts)) -- metadata /user/name\nngx.say("name: ", opts.matched.name) -- name: bobur\n\nlocal opts = {\n    method = "POST",\n    var = ngx.var,\n    matched = {}\n}\n\n-- matches the third route\n-- the value for `arg_access` is obtained from `ngx.var`\nngx.say(rx:match("/admin/nicolas", opts)) -- metadata /admin/name\nngx.say("admin name: ", opts.matched.name) -- admin name: nicolas\n')),(0,r.kt)("p",null,"The ability to manage a large number of routes efficiently has made APISIX the API gateway of choice for ",(0,r.kt)("a",{parentName:"p",href:"https://api7.ai/category/usercase"},"many large-scale projects"),"."),(0,r.kt)("h2",{id:"look-under-the-hood"},"Look under the Hood"),(0,r.kt)("p",null,"There is only so much I can explain about the inner workings of APISIX in one article."),(0,r.kt)("p",null,"But the best part is that the libraries mentioned here and Apache APISIX are ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/apache/apisix/"},"entirely open source"),", meaning you can look under the hood and modify things yourself."),(0,r.kt)("p",null,"And if you can improve APISIX to get that final bit of performance, you can ",(0,r.kt)("a",{parentName:"p",href:"https://apisix.apache.org/docs/general/contributor-guide/"},"contribute the changes")," back to the project and let everyone benefit from your work."))}c.isMDXComponent=!0}}]);