"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[63356],{35318:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>g});var n=a(27378);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=n.createContext({}),c=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=c(e.components);return n.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),d=c(a),g=o,h=d["".concat(s,".").concat(g)]||d[g]||u[g]||r;return a?n.createElement(h,i(i({ref:t},p),{},{components:a})):n.createElement(h,i({ref:t},p))}));function g(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var c=2;c<r;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},49623:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var n=a(25773),o=(a(27378),a(35318));const r={title:"gRPC on the client side",authors:[{name:"Nicolas Fr\xe4nkel",title:"Author",url:"https://github.com/nfrankel",image_url:"https://avatars.githubusercontent.com/u/752258"}],keywords:["gPRC","Protocol Buffers","Spring Boot","Solutions Architecture"],description:"Most inter-systems communication components that use REST serialize their payload in JSON. As of now, JSON lacks a widely-used schema validation standard: JSON Schema is not widespread. Standard schema validation allows delegating the validation to a third-party library and being done with it. Without one, we must fall back to manual validation in the code. Worse, we must keep the validation code in sync with the schema. XML has schema validation out-of-the-box: an XML document can declare a grammar that it must conform to. SOAP, being based on XML, benefits from it too. Other serialization alternatives have a schema validation option: e.g., Avro, Kryo and Protocol Buffers. Interestingly enough, gRPC uses Protobuf to offer RPC across distributed components:\n",tags:["Ecosystem"],image:"https://static.apiseven.com/uploads/2023/06/08/DOxFlzQc_grpc.svg"},i=void 0,l={permalink:"/blog/2023/03/16/grpc-client-side",source:"@site/blog/2023/03/16/grpc-client-side.md",title:"gRPC on the client side",description:"Most inter-systems communication components that use REST serialize their payload in JSON. As of now, JSON lacks a widely-used schema validation standard: JSON Schema is not widespread. Standard schema validation allows delegating the validation to a third-party library and being done with it. Without one, we must fall back to manual validation in the code. Worse, we must keep the validation code in sync with the schema. XML has schema validation out-of-the-box: an XML document can declare a grammar that it must conform to. SOAP, being based on XML, benefits from it too. Other serialization alternatives have a schema validation option: e.g., Avro, Kryo and Protocol Buffers. Interestingly enough, gRPC uses Protobuf to offer RPC across distributed components:\n",date:"2023-03-16T00:00:00.000Z",formattedDate:"March 16, 2023",tags:[{label:"Ecosystem",permalink:"/blog/tags/ecosystem"}],readingTime:8.015,truncated:!0,authors:[{name:"Nicolas Fr\xe4nkel",title:"Author",url:"https://github.com/nfrankel",image_url:"https://avatars.githubusercontent.com/u/752258",imageURL:"https://avatars.githubusercontent.com/u/752258"}],prevItem:{title:"Biweekly Report (Feb 27 - Mar 12)",permalink:"/blog/2023/03/17/weekly-report-0312"},nextItem:{title:"Release Apache APISIX 3.2.0",permalink:"/blog/2023/03/10/release-apache-apisix-3.2.0"}},s={authorsImageUrls:[void 0]},c=[{value:"A simple gRPC service",id:"a-simple-grpc-service",children:[],level:2},{value:"Testing the gRPC service",id:"testing-the-grpc-service",children:[],level:2},{value:"Accessing the gRPC service with regular tools",id:"accessing-the-grpc-service-with-regular-tools",children:[],level:2},{value:"Benefits of transcoding",id:"benefits-of-transcoding",children:[],level:2},{value:"Conclusion",id:"conclusion",children:[],level:2}],p={toc:c};function u(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"In this post, we will briefly describe gRPC and how it benefits inter-service communication.")),(0,o.kt)("head",null,(0,o.kt)("link",{rel:"canonical",href:"https://blog.frankel.ch/grpc-client-side/"})),(0,o.kt)("p",null,"Most inter-systems communication components that use REST serialize their payload in JSON. As of now, JSON lacks a widely-used schema validation standard: ",(0,o.kt)("a",{parentName:"p",href:"https://json-schema.org/"},"JSON Schema")," is not widespread. Standard schema validation allows delegating the validation to a third-party library and being done with it. Without one, we must fall back to manual validation in the code. Worse, we must keep the validation code in sync with the schema."),(0,o.kt)("p",null,"XML has schema validation out-of-the-box: an XML document can declare a grammar that it must conform to. SOAP, being based on XML, benefits from it too."),(0,o.kt)("p",null,"Other serialization alternatives have a schema validation option: ",(0,o.kt)("em",{parentName:"p"},"e.g."),", ",(0,o.kt)("a",{parentName:"p",href:"https://avro.apache.org/"},"Avro"),", ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/EsotericSoftware/kryo"},"Kryo")," and ",(0,o.kt)("a",{parentName:"p",href:"https://protobuf.dev/"},"Protocol Buffers"),". Interestingly enough, gRPC uses Protobuf to offer RPC across distributed components:"),(0,o.kt)("p",null,"gRPC is a modern open source high performance Remote Procedure Call (RPC) framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking and authentication. It is also applicable in last mile of distributed computing to connect devices, mobile applications and browsers to backend services. -- ",(0,o.kt)("a",{parentName:"p",href:"https://grpc.io/"},"Why gRPC?")),(0,o.kt)("p",null,"Moreover, Protocol is a ",(0,o.kt)("em",{parentName:"p"},"binary")," serialization mechanism, saving a lot of bandwidth. Thus, gRPC is an excellent option for inter-systems communication. But if all your components talk gRPC, how can simple clients call them? In this post, we will build a gRPC service and show how to call it from curl."),(0,o.kt)("h2",{id:"a-simple-grpc-service"},"A simple gRPC service"),(0,o.kt)("p",null,"The ",(0,o.kt)("a",{parentName:"p",href:"https://grpc.io/docs/"},"gRPC documentation")," is exhaustive, so here's a summary:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"gRPC is a Remote Procedure Call framework")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"It works across a wide range of languages")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"It relies on Protocol Buffers:"),(0,o.kt)("blockquote",{parentName:"li"},(0,o.kt)("p",{parentName:"blockquote"},"Protocol buffers are Google\u2019s language-neutral, platform-neutral, extensible mechanism for serializing structured data \u2013 think XML, but smaller, faster, and simpler. You define how you want your data to be structured once, then you can use special generated source code to easily write and read your structured data to and from a variety of data streams and using a variety of languages."),(0,o.kt)("p",{parentName:"blockquote"},"-- ",(0,o.kt)("a",{parentName:"p",href:"https://protobuf.dev/"},"Protocol Buffers")))),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"It's part of the ",(0,o.kt)("a",{parentName:"p",href:"https://www.cncf.io/"},"CNCF")," portfolio and is currently in the incubation stage"))),(0,o.kt)("p",null,"Let's set up our gRPC service. We will use Java, Kotlin, Spring Boot, and a dedicated gRPC Spring Boot integration project. The project structure holds two projects, one for the model and one for the code. Let's start with the model project."),(0,o.kt)("p",null,"I didn't want something complicated; reusing a simple example is enough: the request sends a string, and the response prefixes it with ",(0,o.kt)("inlineCode",{parentName:"p"},"Hello"),". We design this model in a dedicated Protobuf schema file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-proto"},'syntax = "proto3";                                        //1\n\npackage ch.frankel.blog.grpc.model;                       //2\n\noption java_multiple_files = true;                        //3\noption java_package = "ch.frankel.blog.grpc.model";       //3\noption java_outer_classname = "HelloProtos";              //3\n\nservice HelloService {                                    //4\n    rpc SayHello (HelloRequest) returns (HelloResponse) {\n    }\n}\n\nmessage HelloRequest {                                    //5\n    string name = 1;                                      //6\n}\n\nmessage HelloResponse {                                   //7\n    string message = 1;                                   //6\n}\n')),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Protobuf definition version"),(0,o.kt)("li",{parentName:"ol"},"Package"),(0,o.kt)("li",{parentName:"ol"},"Java-specific configuration"),(0,o.kt)("li",{parentName:"ol"},"Service definition"),(0,o.kt)("li",{parentName:"ol"},"Request definition"),(0,o.kt)("li",{parentName:"ol"},"Field definition. First comes the type, then the name, and finally, the order"),(0,o.kt)("li",{parentName:"ol"},"Response definition")),(0,o.kt)("p",null,"We shall use Maven to generate the Java boilerplate code:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-xml"},"<project>\n  <dependencies>\n    <dependency>\n      <groupId>io.grpc</groupId>                         \x3c!--1--\x3e\n      <artifactId>grpc-stub</artifactId>\n      <version>${grpc.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>io.grpc</groupId>                         \x3c!--1--\x3e\n      <artifactId>grpc-protobuf</artifactId>\n      <version>${grpc.version}</version>\n    </dependency>\n    <dependency>\n      <groupId>jakarta.annotation</groupId>              \x3c!--1--\x3e\n      <artifactId>jakarta.annotation-api</artifactId>\n      <version>1.3.5</version>\n      <optional>true</optional>\n    </dependency>\n  </dependencies>\n  <build>\n    <extensions>\n      <extension>\n        <groupId>kr.motd.maven</groupId>                 \x3c!--2--\x3e\n        <artifactId>os-maven-plugin</artifactId>\n        <version>1.7.1</version>\n      </extension>\n    </extensions>\n    <plugins>\n      <plugin>\n        <groupId>org.xolstice.maven.plugins</groupId>    \x3c!--3--\x3e\n        <artifactId>protobuf-maven-plugin</artifactId>\n        <version>${protobuf-plugin.version}</version>\n        <configuration>\n          <protocArtifact>com.google.protobuf:protoc:${protobuf.version}:exe:${os.detected.classifier}</protocArtifact>\n          <pluginId>grpc-java</pluginId>\n          <pluginArtifact>io.grpc:protoc-gen-grpc-java:${grpc.version}:exe:${os.detected.classifier}</pluginArtifact>\n        </configuration>\n        <executions>\n          <execution>\n            <goals>\n              <goal>compile</goal>\n              <goal>compile-custom</goal>\n            </goals>\n          </execution>\n        </executions>\n      </plugin>\n    </plugins>\n  </build>\n</project>\n")),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Compile-time dependencies"),(0,o.kt)("li",{parentName:"ol"},"Sniff information about the Operating System. Used in the next plugin"),(0,o.kt)("li",{parentName:"ol"},"Generate Java code from the ",(0,o.kt)("inlineCode",{parentName:"li"},"proto")," file")),(0,o.kt)("p",null,"After compilation, the structure should look something like the following:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://static.apiseven.com/uploads/2023/06/08/JkWtxWqP_model.jpeg",alt:"Proto model project structure"})),(0,o.kt)("p",null,"We can package the classes in a JAR and use it in a web app project. The latter is in Kotlin, but only because it's my favourite JVM language."),(0,o.kt)("p",null,"We only need a specific Spring Boot starter dependency to integrate gRPC endpoints with Spring Boot:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-xml"},"<dependency>\n  <groupId>net.devh</groupId>\n  <artifactId>grpc-server-spring-boot-starter</artifactId>\n  <version>2.14.0.RELEASE</version>\n</dependency>\n")),(0,o.kt)("p",null,"Here's the significant bit:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},'@GrpcService                                                        //1\nclass HelloService : HelloServiceImplBase() {                       //2\n  override fun sayHello(\n      request: HelloRequest,                                        //2\n      observer: StreamObserver<HelloResponse>                       //3\n  ) {\n    with(observer) {\n      val reply = HelloResponse.newBuilder()                        //2\n                               .setMessage("Hello ${request.name}") //4\n                               .build()\n      onNext(reply)                                                 //5\n      onCompleted()                                                 //5\n    }\n  }\n}\n')),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The ",(0,o.kt)("inlineCode",{parentName:"li"},"grpc-server-spring-boot-starter")," detects the annotation and works its magic"),(0,o.kt)("li",{parentName:"ol"},"Reference classes generated in the above project"),(0,o.kt)("li",{parentName:"ol"},"The method signature allows a ",(0,o.kt)("inlineCode",{parentName:"li"},"StreamObserver")," parameter. The class comes from ",(0,o.kt)("inlineCode",{parentName:"li"},"grpc-stub.jar")),(0,o.kt)("li",{parentName:"ol"},"Get the request and prefix it to build the response message"),(0,o.kt)("li",{parentName:"ol"},"Play the events")),(0,o.kt)("p",null,"We can now start the web app with ",(0,o.kt)("inlineCode",{parentName:"p"},"./mvnw spring-boot:run"),"."),(0,o.kt)("h2",{id:"testing-the-grpc-service"},"Testing the gRPC service"),(0,o.kt)("p",null,"The whole idea behind the post is that accessing the gRPC service with regular tools is impossible. To test, we need a dedicated tool nonetheless. I found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/fullstorydev/grpcurl"},"grpcurl"),". Let's install it and use it to list available services:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"grpcurl --plaintext localhost:9090 list   #1-2\n")),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"List all available gRPC services ",(0,o.kt)("strong",{parentName:"li"},"without")," TLS verification"),(0,o.kt)("li",{parentName:"ol"},"To avoid clashes between gRPC and other channels, ",(0,o.kt)("em",{parentName:"li"},"e.g."),", REST, Spring Boot uses another port")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"ch.frankel.blog.grpc.model.HelloService   #1\ngrpc.health.v1.Health                     #2\ngrpc.reflection.v1alpha.ServerReflection  #2\n")),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"The gRPC service we defined"),(0,o.kt)("li",{parentName:"ol"},"Two additional services provided by the custom starter")),(0,o.kt)("p",null,"We can also dive into the structure of the service:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"grpcurl --plaintext localhost:9090 describe ch.frankel.blog.grpc.model.HelloService\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"service HelloService {\n  rpc SayHello ( .ch.frankel.blog.grpc.model.HelloRequest ) returns ( .ch.frankel.blog.grpc.model.HelloResponse );\n}\n")),(0,o.kt)("p",null,"Finally, we can call the service with data:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'grpcurl --plaintext -d \'{"name": "John"}\' localhost:9090 ch.frankel.blog.grpc.model.HelloService/SayHello\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "message": "Hello John"\n}\n')),(0,o.kt)("h2",{id:"accessing-the-grpc-service-with-regular-tools"},"Accessing the gRPC service with regular tools"),(0,o.kt)("p",null,"Imagine that we have a regular JavaScript client-side application that needs to access the gRPC service. What would be the alternatives?"),(0,o.kt)("p",null,"The general approach is through ",(0,o.kt)("inlineCode",{parentName:"p"},"grpc-web"),":"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"A JavaScript implementation of gRPC for browser clients. For more information, including a quick start, see the gRPC-web documentation."),(0,o.kt)("p",{parentName:"blockquote"},"gRPC-web clients connect to gRPC services via a special proxy; by default, gRPC-web uses Envoy."),(0,o.kt)("p",{parentName:"blockquote"},"In the future, we expect gRPC-web to be supported in language-specific web frameworks for languages such as Python, Java, and Node. For details, see the roadmap."),(0,o.kt)("p",{parentName:"blockquote"},"-- ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/grpc/grpc-web"},"grpc-web"))),(0,o.kt)("p",null,"The description states a single limitation: it works only for JavaScript (as of now). However, there's another one. It's pretty intrusive. You need to get the ",(0,o.kt)("inlineCode",{parentName:"p"},"proto")," file, generate boilerplate code, and make your code call it. You must do it for every client type. Worse, if the proto file changes, you need to regenerate the client code in each of them."),(0,o.kt)("p",null,"An alternative exists, though, if you're using an API Gateway. I'll describe how to do it with ",(0,o.kt)("a",{parentName:"p",href:"https://apisix.apache.org/"},"Apache APISIX"),", but perhaps other gateways can do the same. ",(0,o.kt)("a",{parentName:"p",href:"https://apisix.apache.org/docs/apisix/plugins/grpc-transcode/"},"grpc-transcode")," is a plugin that allows transcoding REST calls to gRPC and back again."),(0,o.kt)("p",null,"The first step is to register the proto file in Apache APISIX:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'curl http://localhost:9180/apisix/admin/protos/1 -H \'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\' -X PUT -d "{ \\"content\\": \\"$(sed \'s/"/\\\\"/g\' ../model/src/main/proto/model.proto)\\" }"\n')),(0,o.kt)("p",null,"The second step is to create a route with the above plugin:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'curl http://localhost:9180/apisix/admin/routes/1 -H \'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\' -X PUT -d \'\n{\n  "uri": "/helloservice/sayhello",                           #1\n  "plugins": {\n    "grpc-transcode": {\n      "proto_id": "1",                                       #2\n      "service": "ch.frankel.blog.grpc.model.HelloService",  #3\n      "method": "SayHello"                                   #4\n    }\n  },\n  "upstream": {\n    "scheme": "grpc",\n    "nodes": {\n      "server:9090": 1\n    }\n  }\n}\'\n')),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Define a granular route"),(0,o.kt)("li",{parentName:"ol"},"Reference the proto file defined in the previous command"),(0,o.kt)("li",{parentName:"ol"},"gRPC service"),(0,o.kt)("li",{parentName:"ol"},"gRPC method")),(0,o.kt)("p",null,"At this point, ",(0,o.kt)("strong",{parentName:"p"},"any client")," can make an HTTP request to the defined endpoint. Apache APISIX will transcode the call to gRPC, forward it to the defined service, get the response, and transcode it again."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"curl localhost:9080/helloservice/sayhello?name=John\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{"message":"Hello John"}\n')),(0,o.kt)("p",null,"Compared to ",(0,o.kt)("inlineCode",{parentName:"p"},"grpc-web"),", the API Gateway approach allows sharing the ",(0,o.kt)("inlineCode",{parentName:"p"},"proto")," file with a single component: the Gateway itself."),(0,o.kt)("h2",{id:"benefits-of-transcoding"},"Benefits of transcoding"),(0,o.kt)("p",null,"At this point, we can leverage the capabilities of the API Gateway. Imagine we want a default value if no ",(0,o.kt)("inlineCode",{parentName:"p"},"name")," is passed, ",(0,o.kt)("em",{parentName:"p"},"e.g."),", ",(0,o.kt)("inlineCode",{parentName:"p"},"World"),". Developers would happily set it in the code, but any change to the value would require a complete build and deployment. Changes can be nearly-instant if we put the default value in the Gateway's routes processing chain. Let's change our route accordingly:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'curl http://localhost:9180/apisix/admin/routes/1 -H \'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\' -X PUT -d \'\n{\n  "uri": "/helloservice/sayhello",\n  "plugins": {\n    "grpc-transcode": {\n      ...\n    },\n    "serverless-pre-function": {                    #1\n      "phase": "rewrite",                           #2\n      "functions" : [\n        "return function(conf, ctx)                 #3\n          local core = require(\\"apisix.core\\")\n          if not ngx.var.arg_name then\n            local uri_args = core.request.get_uri_args(ctx)\n            uri_args.name = \\"World\\"\n            ngx.req.set_uri_args(uri_args)\n          end\n        end"\n      ]\n    }\n  },\n  "upstream": {\n      ...\n  }\n}\'\n')),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Generic all-purpose plugin when none fits"),(0,o.kt)("li",{parentName:"ol"},"Rewrite the request"),(0,o.kt)("li",{parentName:"ol"},"Magic Lua code that does the trick")),(0,o.kt)("p",null,"Now, we can execute the request with an empty argument and get the expected result:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"curl localhost:9080/helloservice/sayhello?name\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{"message":"Hello World"}\n')),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"In this post, we have briefly described gRPC and how it benefits inter-service communication. We developed a simple gRPC service using Spring Boot and ",(0,o.kt)("inlineCode",{parentName:"p"},"grpc-server-spring-boot-starter"),". It comes at a cost, though: regular clients cannot access the service. We had to resort to ",(0,o.kt)("inlineCode",{parentName:"p"},"grpcurl")," to test it. The same goes for clients based on JavaScript - or the browser."),(0,o.kt)("p",null,"To bypass this limitation, we can leverage an API Gateway. I demoed how to configure Apache APISIX with the ",(0,o.kt)("inlineCode",{parentName:"p"},"grpc-transcode")," plugin to achieve the desired result."),(0,o.kt)("p",null,"The complete source code for this post can be found on ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ajavageek/grpc-apisix"},"GitHub"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"To go further:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://grpc.io/"},"gRPC")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://protobuf.dev/"},"Protocol Buffers")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/trustin/os-maven-plugin"},"os-maven-plugin")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/xolstice/protobuf-maven-plugin"},"Maven Protocol Buffers Plugin")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://yidongnan.github.io/grpc-spring-boot-starter/"},"gRPC-Spring-Boot-Starter")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/fullstorydev/grpcurl"},"grpcurl")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://apisix.apache.org"},"Apache APISIX")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://apisix.apache.org/docs/apisix/plugins/grpc-transcode/"},"grpc-transcode plugin"))))}u.isMDXComponent=!0}}]);