"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[18153],{35318:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var a=t(27378);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=a.createContext({}),u=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},p=function(e){var n=u(e.components);return a.createElement(s.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),d=u(t),h=i,m=d["".concat(s,".").concat(h)]||d[h]||c[h]||r;return t?a.createElement(m,l(l({ref:n},p),{},{components:t})):a.createElement(m,l({ref:n},p))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,l=new Array(r);l[0]=d;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var u=2;u<r;u++)l[u]=t[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},84478:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>c,frontMatter:()=>r,metadata:()=>o,toc:()=>u});var a=t(25773),i=(t(27378),t(35318));const r={title:"Creating a Custom Data Mask Plugin",authors:[{name:"Zeping Bai",title:"Author",url:"https://github.com/bzp2010",image_url:"https://avatars.githubusercontent.com/u/8078418?v=4"},{name:"Navendu Pottekkat",title:"Author",url:"https://github.com/navendu-pottekkat",image_url:"https://avatars.githubusercontent.com/u/49474499"}],keywords:["Plugin","Lua","OpenResty","Data mask"],description:"A tutorial on creating a custom Apache APISIX plugin in Lua through a real use case.",tags:["Plugins"],image:"https://static.apiseven.com/uploads/2023/07/13/p0iSJGOY_data-mask-cover.png"},l=void 0,o={permalink:"/blog/2023/07/20/data-mask-plugin",source:"@site/blog/2023/07/20/data-mask-plugin.md",title:"Creating a Custom Data Mask Plugin",description:"A tutorial on creating a custom Apache APISIX plugin in Lua through a real use case.",date:"2023-07-20T00:00:00.000Z",formattedDate:"July 20, 2023",tags:[{label:"Plugins",permalink:"/blog/tags/plugins"}],readingTime:9,truncated:!0,authors:[{name:"Zeping Bai",title:"Author",url:"https://github.com/bzp2010",image_url:"https://avatars.githubusercontent.com/u/8078418?v=4",imageURL:"https://avatars.githubusercontent.com/u/8078418?v=4"},{name:"Navendu Pottekkat",title:"Author",url:"https://github.com/navendu-pottekkat",image_url:"https://avatars.githubusercontent.com/u/49474499",imageURL:"https://avatars.githubusercontent.com/u/49474499"}],prevItem:{title:"Release Apache APISIX 3.4.1",permalink:"/blog/2023/07/21/release-apache-apisix-3.4.1"},nextItem:{title:"Biweekly Report (July 03 - July 16)",permalink:"/blog/2023/07/18/weekly-report"}},s={authorsImageUrls:[void 0,void 0]},u=[{value:"Setting Things Up",id:"setting-things-up",children:[],level:2},{value:"Designing the Plugin",id:"designing-the-plugin",children:[],level:2},{value:"Let&#39;s Write Some Code!",id:"lets-write-some-code",children:[],level:2},{value:"Testing the Plugin",id:"testing-the-plugin",children:[],level:2},{value:"Using in Production",id:"using-in-production",children:[],level:2},{value:"Learn More",id:"learn-more",children:[],level:2}],p={toc:u};function c(e){let{components:n,...t}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Creating a custom plugin for APISIX in Lua might be trivial or daunting, depending on your level of expertise in APISIX+OpenResty+Nginx. In this article, we will look at how you can create and run a custom plugin from the ground up while learning some basics of APISIX plugin development.")),(0,i.kt)("p",null,"When talking to one of our users from the fintech industry during the ",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=vRwAuvfZIgE"},"Apache APISIX Community Meetup in Malaysia"),", we came across a peculiar feature request: mask confidential data in responses."),(0,i.kt)("p",null,"For example, a response from the upstream might contain sensitive data like credit card numbers, and APISIX should be able to replace it with ",(0,i.kt)("inlineCode",{parentName:"p"},"*******")," based on some predefined rules."),(0,i.kt)("p",null,"Creating such a plugin in Lua might be trivial or daunting, depending on your level of expertise in APISIX+OpenResty+Nginx. So in this article, we will look at how you can create and run this plugin from the ground up while learning some basics of APISIX plugin development in Lua."),(0,i.kt)("h2",{id:"setting-things-up"},"Setting Things Up"),(0,i.kt)("p",null,"You can start with the template plugin from ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/api7/apisix-plugin-template"},"apisix-plugin-template"),". This contains ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/api7/apisix-plugin-template/blob/main/apisix/plugins/demo.lua"},"boilerplate code")," for creating custom Lua plugins for APISIX."),(0,i.kt)("p",null,'To use the template, go to the repository and click "',(0,i.kt)("a",{parentName:"p",href:"https://github.com/new?template_name=apisix-plugin-template&template_owner=api7"},"Use this template"),'." You can then clone it to your local machine for modification.'),(0,i.kt)("p",null,"Under the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/api7/apisix-plugin-template/tree/main/apisix/plugins"},"apisix/plugins")," directory, you will find a file named ",(0,i.kt)("inlineCode",{parentName:"p"},"demo.lua"),". You can rename this to ",(0,i.kt)("inlineCode",{parentName:"p"},"data-mask.lua"),". This will be the starting point for our custom plugin."),(0,i.kt)("p",null,"Initially, the main parts of the file will look like this containing some boilerplate code which includes some imports and variable definitions:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua",metastring:'{title="data-mask.lua"}',"{title":'"data-mask.lua"}'},'-- local common libs\nlocal require = require\nlocal core    = require("apisix.core")\n\n-- module define\nlocal plugin_name = "data-mask"\n\n-- plugin schema\nlocal plugin_schema = {\n    type = "object",\n    properties = {},\n    required = {},\n}\n\nlocal _M = {\n    version  = 0.1,            -- plugin version\n    priority = 0,              -- the priority of this plugin will be 0\n    name     = plugin_name,    -- plugin name\n    schema   = plugin_schema,  -- plugin schema\n}\n\n\n-- module interface for schema check\n-- @param `conf` user defined conf data\n-- @param `schema_type` defined in `apisix/core/schema.lua`\n-- @return <boolean>\nfunction _M.check_schema(conf, schema_type)\n    return core.schema.check(plugin_schema, conf)\nend\n\n\n-- module interface for header_filter phase\nfunction _M.header_filter(conf, ctx)\n\nend\n\n\n-- module interface for body_filter phase\nfunction _M.body_filter(conf, ctx)\n\nend\n\nreturn _M\n')),(0,i.kt)("p",null,"There are three functions (interfaces for the plugin) declared on the structure ",(0,i.kt)("inlineCode",{parentName:"p"},"_M"),":"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"check_schema"),": used for validating the plugin configuration and is called when this plugin is enabled on a route."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"header_filter")," and"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"body_filter"),": for modifying the response header and body, respectively, before sending it to the client.")),(0,i.kt)("p",null,"In the end, this returns ",(0,i.kt)("inlineCode",{parentName:"p"},"_M"),", and the APISIX can use the data from this to get the metadata and functions from the plugin."),(0,i.kt)("h2",{id:"designing-the-plugin"},"Designing the Plugin"),(0,i.kt)("p",null,"Like every sound engineer, let's first design the plugin before we start writing code."),(0,i.kt)("p",null,"The goal of this plugin is simple:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The user should be able to define what sensitive data would look like in the plugin configuration (maybe RegEx?)."),(0,i.kt)("li",{parentName:"ol"},"They should be able to define what sensitive data should be replaced with (like\xa0",(0,i.kt)("inlineCode",{parentName:"li"},"*******"),")."),(0,i.kt)("li",{parentName:"ol"},"APISIX should then modify requests and responses based on these configurations.")),(0,i.kt)("p",null,"So each rule can contain a regular expression and a replacement string. This rule will be applied to the response, and the masked data will be returned to the client:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "rules": [\n    {\n      "regex": ".*",\n      "replace": "******"\n    },\n    {\n      "regex": ".*",\n      "replace": "**"\n    }\n  ]\n}\n')),(0,i.kt)("p",null,"We can now define the JSON schema to validate the plugin configuration. This can help avoid issues with improper plugin configurations during runtime:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'local plugin_schema = {\n    type = "object",\n    properties = {\n        rules = {\n            type = "array",\n            items = {\n                type = "object",\n                properties = {\n                    regex = {\n                        type = "string",\n                        minLength = 1,\n                    },\n                    replace = {\n                        type = "string",\n                    },\n                },\n                required = {\n                    "regex",\n                    "replace",\n                },\n                additionalProperties = false,\n            },\n            minItems = 1,\n        },\n    },\n    required = {\n        "rules",\n    },\n}\n')),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"rules")," here is an array of objects meaning you can have multiple rules for defining what sensitive data should look like and what it should be replaced with. Each object in the array contains two required string fields, ",(0,i.kt)("inlineCode",{parentName:"p"},"regex")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"replace"),", just like we designed."),(0,i.kt)("h2",{id:"lets-write-some-code"},"Let's Write Some Code!"),(0,i.kt)("p",null,"We have now decided what the plugin's functionality would look like and added some JSON schema to validate the plugin's configuration."),(0,i.kt)("p",null,"We will first modify the ",(0,i.kt)("inlineCode",{parentName:"p"},"_M.header_filter")," function, which is called before the response header is sent to the client. But why are we changing this? Isn't our plugin supposed to modify the response body?"),(0,i.kt)("p",null,"Well, yes. But when we modify the data in the response body (from ",(0,i.kt)("inlineCode",{parentName:"p"},"2378-4531-5789-1369")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"2378-\\***\\*-\\*\\***-1369"),"), the ",(0,i.kt)("inlineCode",{parentName:"p"},"Content-Length")," header will no longer be accurate. This can cause the client to interpret that the data returned by the server is abnormal and fail to complete the request."),(0,i.kt)("p",null,"Since we haven't modified the request body yet, we cannot calculate the new, accurate value for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Content-Length")," header.\xa0 So we need to delete this header value, modify the response body, recalculate the new header value, and set it to the response. To do this in a single sweep, APISIX provides the ",(0,i.kt)("inlineCode",{parentName:"p"},"core.response.clear_header_as_body_modified")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"function _M.header_filter(conf, ctx)\n    core.response.clear_header_as_body_modified()\nend\n")),(0,i.kt)("p",null,"We can now work on modifying the response body to mask the data. To do this, we must modify the ",(0,i.kt)("inlineCode",{parentName:"p"},"_M.body_filter")," function."),(0,i.kt)("p",null,"Sometimes, the upstream response will be sent in chunks (",(0,i.kt)("inlineCode",{parentName:"p"},"Content-Encoding: chunked"),"), and the ",(0,i.kt)("inlineCode",{parentName:"p"},"body_filter")," function will be called multiple times. Since each of these chunks are incomplete in itself, we need to cache the data passed each time and call the ",(0,i.kt)("inlineCode",{parentName:"p"},"body_filter")," function only when all blocks are received and spliced together. And like before, APISIX provides a function, ",(0,i.kt)("inlineCode",{parentName:"p"},"core.response.hold_body_chunk")," to handle this scenario:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"local body = core.response.hold_body_chunk(ctx)\nif not body then\n    return\nend\n")),(0,i.kt)("p",null,"Now to mask the response data, we can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"ngx.re.gsub")," function, which takes in a regular expression and a replacement string and replaces matching strings with the replacement string."),(0,i.kt)("p",null,"The RegEx conforms to the PCRE specification. For example, when the expression is ",(0,i.kt)("inlineCode",{parentName:"p"},"(.*)-(.*)-(.*)-(.*)"),", it will extract the four variables separated by ",(0,i.kt)("inlineCode",{parentName:"p"},"-"),", and you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"$1"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"$2"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"$3"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"$4")," in the replacement string to refer to the four variables:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'for _, rule in ipairs(conf.rules) do\n    body = ngx.re.gsub(body, rule.regex, rule.replace, "jo")\nend\n')),(0,i.kt)("p",null,"Finally, to set this as the new response body, we will modify the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"ngx.arg[1]")," as mentioned in the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/openresty/lua-nginx-module/#body_filter_by_lua_block"},"OpenResty docs"),". Once we set the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"ngx.arg[2]")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", APISIX will send the new response body to the client:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},"ngx.arg[1] = body\nngx.arg[2] = true\n")),(0,i.kt)("p",null,"Combining all these, the ",(0,i.kt)("inlineCode",{parentName:"p"},"body_filter")," function will look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'function _M.body_filter(conf, ctx)\n    local body = core.response.hold_body_chunk(ctx)\n    if not body then\n        return\n    end\n\n    for _, rule in ipairs(conf.rules) do\n        body = ngx.re.gsub(body, rule.regex, rule.replace, "jo")\n    end\n\n    ngx.arg[1] = body\n    ngx.arg[2] = true\nend\n')),(0,i.kt)("p",null,"Now the only thing left to do is glue everything together. The entire plugin code will look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'-- local common libs\nlocal require     = require\nlocal ipairs      = ipairs\nlocal ngx_re_gsub = ngx.re.gsub\nlocal core        = require("apisix.core")\n\n-- module define\nlocal plugin_name = "data-mask"\n\n-- plugin schema\nlocal plugin_schema = {\n    type = "object",\n    properties = {\n        rules = {\n            type = "array",\n            items = {\n                type = "object",\n                properties = {\n                    regex = {\n                        type = "string",\n                        minLength = 1,\n                    },\n                    replace = {\n                        type = "string",\n                    },\n                },\n                required = {\n                    "regex",\n                    "replace",\n                },\n                additionalProperties = false,\n            },\n            minItems = 1,\n        },\n    },\n    required = {\n        "rules",\n    },\n}\n\nlocal _M = {\n    version  = 0.1,            -- plugin version\n    priority = 0,              -- the priority of this plugin will be 0\n    name     = plugin_name,    -- plugin name\n    schema   = plugin_schema,  -- plugin schema\n}\n\n\n-- module interface for schema check\n-- @param `conf` user defined conf data\n-- @param `schema_type` defined in `apisix/core/schema.lua`\n-- @return <boolean>\nfunction _M.check_schema(conf, schema_type)\n    return core.schema.check(plugin_schema, conf)\nend\n\n\n-- module interface for header_filter phase\nfunction _M.header_filter(conf, ctx)\n    core.response.clear_header_as_body_modified()\nend\n\n\n-- module interface for body_filter phase\nfunction _M.body_filter(conf, ctx)\n    local body = core.response.hold_body_chunk(ctx)\n    if not body then\n        return\n    end\n\n    for _, rule in ipairs(conf.rules) do\n        body = ngx_re_gsub(body, rule.regex, rule.replace, "jo")\n    end\n\n    ngx.arg[1] = body\n    ngx.arg[2] = true\nend\n\nreturn _M\n')),(0,i.kt)("h2",{id:"testing-the-plugin"},"Testing the Plugin"),(0,i.kt)("p",null,"Let's assume our upstream will return a response like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "username": "jack",\n  "credit_number": "2378-4531-5789-1369"\n}\n')),(0,i.kt)("p",null,"It contains the username and the credit card number, which is far from ideal. We can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"data-mask")," plugin to rewrite it to ",(0,i.kt)("inlineCode",{parentName:"p"},"2378-****-****-1369"),". The configuration would look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "rules": [\n    {\n      "regex": "\\"credit_number\\":\\"(.*)-(.*)-(.*)-(.*)\\"",\n      "replace": "\\"credit_number\\":\\"$1-****-****-$4\\""\n    }\n  ]\n}\n')),(0,i.kt)("p",null,"A common way the APISIX plugin developers debug plugins by mocking upstream response is through the ",(0,i.kt)("a",{parentName:"p",href:"https://apisix.apache.org/docs/apisix/plugins/serverless/"},"serverless-pre-function")," plugin. Through this plugin, you can run custom Lua code, in our case, to send back a response with un-masked credit card numbers:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-lua"},'return function()\n    ngx.header["Content-Type"] = "application/json";\n    require("apisix.core").response.exit(200, {\n        credit_number = "1234-5678-8765-4321",\n        username = "jack"\n    })\nend\n')),(0,i.kt)("p",null,"We can configure both our custom plugin and the ",(0,i.kt)("inlineCode",{parentName:"p"},"serverless-pre-function")," plugin on the same route as shown below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'curl -X PUT \'http://localhost:9180/apisix/admin/routes/data-mask\' \\\n-H \'X-API-KEY: edd1c9f034335f136f87ad84b625c8f1\' \\\n-H \'Content-Type: application/json\' \\\n--data \'{\n    "uri": "/data-mask",\n    "plugins": {\n        "serverless-pre-function": {\n            "phase": "access",\n            "functions": [\n                "return function() ngx.header[\\"Content-Type\\"] = \\"application/json\\"; require(\\"apisix.core\\").response.exit(200, {credit_number = \\"1234-5678-8765-4321\\", username = \\"jack\\"}) end"\n            ]\n        },\n        "data-mask": {\n            "rules": [\n                {\n                    "regex":"\\"credit_number\\":\\"(.*)-(.*)-(.*)-(.*)\\"",\n                    "replace": "\\"credit_number\\":\\"$1-****-****-$4\\""\n                }\n            ]\n        }\n    }\n}\'\n')),(0,i.kt)("p",null,"Now if you send a request to the route, you will get back the masked credit card numbers in the response:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'curl -X GET \'http://localhost:9080/data-mask\'\n\n{\n  "username": "jack",\n  "credit_number": "1234-****-****-4321"\n}\n')),(0,i.kt)("h2",{id:"using-in-production"},"Using in Production"),(0,i.kt)("p",null,"You can directly build your own APISIX image with this plugin included for using it in production:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-dockerfile"},"FROM apache/apisix:3.3.0-debian\n\nCOPY ./data-mask.lua /usr/local/apisix/apisix/plugins/data-mask.lua\n")),(0,i.kt)("p",null,"Then run ",(0,i.kt)("inlineCode",{parentName:"p"},"docker build"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"docker build -t your-own-registry.com/apisix:3.3.0-data-mask .\n")),(0,i.kt)("p",null,"Next, in the configuration file (",(0,i.kt)("inlineCode",{parentName:"p"},"config.yaml"),") you can add your plugin to the list:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},"plugins:\n  # any other plugins from config-default.yaml\n  - xxxx\n  - data-mask\n")),(0,i.kt)("p",null,"Note: The values in ",(0,i.kt)("inlineCode",{parentName:"p"},"plugins")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"config.yaml")," file override those in the ",(0,i.kt)("inlineCode",{parentName:"p"},"config-default.yaml")," file. If you want to use other plugins, copy it to the ",(0,i.kt)("inlineCode",{parentName:"p"},"config.yaml")," file."),(0,i.kt)("p",null,"Once you add it to the configuration file, you should be able to use the plugin on your routes."),(0,i.kt)("h2",{id:"learn-more"},"Learn More"),(0,i.kt)("p",null,"All the sample code from this article can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/bzp2010/apisix-plugin-data-mask/blob/main/apisix/plugins/data-mask.lua"},"here"),". You can also use the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/api7/apisix-plugin-template"},"plugin template")," to create your own plugins easily."),(0,i.kt)("p",null,"APISIX comes with many in-built plugins; you can refer to its ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/apache/apisix/tree/master/apisix/plugins"},"source code")," for more details on how you can create your own plugins. You can also refer to the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/openresty/lua-nginx-module"},"lua-nginx-module")," and this ",(0,i.kt)("a",{parentName:"p",href:"https://api7.ai/learning-center/openresty"},"series of OpenResty tutorials")," to learn more."))}c.isMDXComponent=!0}}]);