"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[54350],{35318:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(27378);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=p(n),d=r,m=h["".concat(l,".").concat(d)]||h[d]||u[d]||o;return n?a.createElement(m,i(i({ref:t},c),{},{components:n})):a.createElement(m,i({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},81075:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(25773),r=(n(27378),n(35318));const o={title:"Implementing the Idempotency-Key specification on Apache APISIX",authors:[{name:"Nicolas Fr\xe4nkel",title:"Author",url:"https://github.com/nfrankel",image_url:"https://avatars.githubusercontent.com/u/752258"}],keywords:["APISIX","Idempotency","IETF","specification","plugin","coding"],description:"Last week, I wrote an analysis of the IETF Idempotency-Key specification. The specification aims to avoid duplicated requests. In short, the idea is for the client to send a unique key along with the request: If the server doesn't know the key, it proceeds as usual and then stores the response. If the server knows the key, it short-circuits any further processing and immediately returns the stored response. This post shows how to implement it with Apache APISIX.\n",tags:["Plugin"],image:"https://static.apiseven.com/uploads/2024/04/09/0rfsRevo_stormtrooper-2899993.jpg"},i=void 0,s={permalink:"/blog/2024/04/11/implement-idempotency-key-apisix",source:"@site/blog/2024/04/11/implement-idempotency-key-apisix.md",title:"Implementing the Idempotency-Key specification on Apache APISIX",description:"Last week, I wrote an analysis of the IETF Idempotency-Key specification. The specification aims to avoid duplicated requests. In short, the idea is for the client to send a unique key along with the request: If the server doesn't know the key, it proceeds as usual and then stores the response. If the server knows the key, it short-circuits any further processing and immediately returns the stored response. This post shows how to implement it with Apache APISIX.\n",date:"2024-04-11T00:00:00.000Z",formattedDate:"April 11, 2024",tags:[{label:"Plugin",permalink:"/blog/tags/plugin"}],readingTime:9.995,truncated:!0,authors:[{name:"Nicolas Fr\xe4nkel",title:"Author",url:"https://github.com/nfrankel",image_url:"https://avatars.githubusercontent.com/u/752258",imageURL:"https://avatars.githubusercontent.com/u/752258"}],prevItem:{title:"Release Apache APISIX 3.9.1",permalink:"/blog/2024/04/29/release-apache-apisix-3.9.1"},nextItem:{title:"How to build APISIX in SLES 15",permalink:"/blog/2024/04/05/build-apisix-in-sles15"}},l={authorsImageUrls:[void 0]},p=[{value:"Overview",id:"overview",children:[],level:2},{value:"Laying out the plugin",id:"laying-out-the-plugin",children:[],level:2},{value:"Implementing the nominal path",id:"implementing-the-nominal-path",children:[],level:2},{value:"Implementing error paths",id:"implementing-error-paths",children:[],level:2},{value:"Conclusion",id:"conclusion",children:[],level:2}],c={toc:p};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("head",null,(0,r.kt)("link",{rel:"canonical",href:"https://blog.frankel.ch/implement-idempotency-key-apisix/"})),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Last week, I wrote an ",(0,r.kt)("a",{parentName:"p",href:"https://apisix.apache.org/blog/2024/04/04/fix-duplicate-api-requests/"},"analysis")," of the ",(0,r.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/draft-ietf-httpapi-idempotency-key-header-04"},"IETF Idempotency-Key specification"),". The specification aims to avoid duplicated requests. In short, the idea is for the client to send a unique key along with the request:"),(0,r.kt)("ul",{parentName:"blockquote"},(0,r.kt)("li",{parentName:"ul"},"If the server doesn't know the key, it proceeds as usual and then stores the response"),(0,r.kt)("li",{parentName:"ul"},"If the server knows the key, it short-circuits any further processing and immediately returns the stored response")),(0,r.kt)("p",{parentName:"blockquote"},"This post shows how to implement it with ",(0,r.kt)("a",{parentName:"p",href:"https://apisix.apache.org/"},"Apache APISIX"),".")),(0,r.kt)("h2",{id:"overview"},"Overview"),(0,r.kt)("p",null,"Before starting coding, we need to define a couple of things. Apache APISIX offers a plugin-based architecture. Hence, we will code the above logic in a plugin."),(0,r.kt)("p",null,"Apache APISIX builds upon OpenResty, which builds upon nginx. Each component defines phases, which map more or less across the components. For more info on phases, please see ",(0,r.kt)("a",{parentName:"p",href:"https://apisix.apache.org/blog/2023/12/14/apisix-plugins-priority-leaky-abstraction/"},"this previous post"),"."),(0,r.kt)("p",null,"Finally, we shall decide on a priority. Priority defines the order in which APISIX runs plugins ",(0,r.kt)("em",{parentName:"p"},"inside a phase"),". I decided on ",(0,r.kt)("inlineCode",{parentName:"p"},"1500"),", as all authentication plugins have a priority in the ",(0,r.kt)("inlineCode",{parentName:"p"},"2000")," and more range, but I want to return the cached response ASAP."),(0,r.kt)("p",null,"The specification requires us to store data. APISIX offers many abstractions, but storage is not one of them. We need access via the idempotency key so it looks like a key-value store."),(0,r.kt)("p",null,"I arbitrarily chose Redis, as it's pretty widespread ",(0,r.kt)("strong",{parentName:"p"},"and")," the client is already part of the APISIX distribution. Note that simple Redis doesn't offer JSON storage; hence, I use the ",(0,r.kt)("inlineCode",{parentName:"p"},"redis-stack")," Docker image."),(0,r.kt)("p",null,"The local infrastructure is the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'services:\n  apisix:\n    image: apache/apisix:3.9.0-debian\n    volumes:\n      - ./apisix/config.yml:/usr/local/apisix/conf/config.yaml:ro\n      - ./apisix/apisix.yml:/usr/local/apisix/conf/apisix.yaml:ro #1\n      - ./plugin/src:/opt/apisix/plugins:ro                  #2\n    ports:\n      - "9080:9080"\n  redis:\n    image: redis/redis-stack:7.2.0-v9\n    ports:\n      - "8001:8001"                                          #3\n')),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Static route configuration"),(0,r.kt)("li",{parentName:"ol"},"Path to our future plugin"),(0,r.kt)("li",{parentName:"ol"},"Port of Redis Insights (GUI). Not necessary ",(0,r.kt)("em",{parentName:"li"},"per se"),", but very useful during development for debugging")),(0,r.kt)("p",null,"The APISIX configuration is the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"deployment:\n  role: data_plane\n  role_data_plane:\n    config_provider: yaml                                    #1\n\napisix:\n  extra_lua_path: /opt/?.lua                                 #2\n\nplugins:\n  - idempotency                    # priority: 1500          #3\n\nplugin_attr:                                                 #4\n  idempotency:\n    host: redis                                              #5\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Configure APISIX for static routes configuration"),(0,r.kt)("li",{parentName:"ol"},"Configure the location of our plugin"),(0,r.kt)("li",{parentName:"ol"},"Custom plugins need to be explicitly declared. The priority comment is not required but is good practice and improves maintainability"),(0,r.kt)("li",{parentName:"ol"},"Common plugin configuration across all routes"),(0,r.kt)("li",{parentName:"ol"},"See below")),(0,r.kt)("p",null,"Finally, we declare our single route:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'routes:\n  - uri: /*\n    plugins:\n      idempotency: ~                                         #1\n    upstream:\n      nodes:\n        "httpbin.org:80": 1                                  #2\n#END                                                         #3\n')),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Declare the plugin that we are going to create"),(0,r.kt)("li",{parentName:"ol"},"httpbin is a useful upstream as we can try different URIs and methods"),(0,r.kt)("li",{parentName:"ol"},"Mandatory for static routes configuration!")),(0,r.kt)("p",null,"With this infrastructure in place, we can start the implementation."),(0,r.kt)("h2",{id:"laying-out-the-plugin"},"Laying out the plugin"),(0,r.kt)("p",null,"The foundations of an Apache APISIX plugin are pretty basic:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local plugin_name = "idempotency"\n\nlocal _M = {\n    version = 1.0,\n    priority = 1500,\n    schema = {},\n    name = plugin_name,\n}\n\nreturn _M\n')),(0,r.kt)("p",null,"The next step is configuration, ",(0,r.kt)("em",{parentName:"p"},"e.g.")," Redis host and port. For starters, we shall offer a single Redis configuration across all routes. That's the idea behind the ",(0,r.kt)("inlineCode",{parentName:"p"},"plugin_attr")," section in the ",(0,r.kt)("inlineCode",{parentName:"p"},"config.yaml")," file: common configuration. Let's flesh out our plugin:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local core = require("apisix.core")\nlocal plugin = require("apisix.plugin")\n\nlocal attr_schema = {                                       --1\n    type = "object",\n    properties = {\n        host = {\n            type = "string",\n            description = "Redis host",\n            default = "localhost",\n        },\n        port = {\n            type = "integer",\n            description = "Redis port",\n            default = 6379,\n        },\n    },\n}\n\nfunction _M.init()\n    local attr = plugin.plugin_attr(plugin_name) or {}\n    local ok, err = core.schema.check(attr_schema, attr)    --2\n    if not ok then\n        core.log.error("Failed to check the plugin_attr[", plugin_name, "]", ": ", err)\n        return false, err\n    end\nend\n')),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Define the shape of the configuration"),(0,r.kt)("li",{parentName:"ol"},"Check the configuration is valid")),(0,r.kt)("p",null,"Because I defined default values in the plugin, I can override only the ",(0,r.kt)("inlineCode",{parentName:"p"},"host")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"redis")," to run inside my Docker Compose infrastructure and use the default port."),(0,r.kt)("p",null,"Next, I need to create the Redis client. Note that the platform prevents me from connecting in any phase after the rewrite/access section. Hence, I'll create it in the ",(0,r.kt)("inlineCode",{parentName:"p"},"init()")," method and keep it until the end."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local redis_new = require("resty.redis").new                --1\n\nfunction _M.init()\n\n    -- ...\n\n    redis = redis_new()                                     --2\n    redis:set_timeout(1000)\n    local ok, err = redis:connect(attr.host, attr.port)\n    if not ok then\n        core.log.error("Failed to connect to Redis: ", err)\n        return false, err\n    end\nend\n')),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Reference the ",(0,r.kt)("inlineCode",{parentName:"li"},"new")," function of the OpenResty Redis module"),(0,r.kt)("li",{parentName:"ol"},"Call it to get an instance")),(0,r.kt)("p",null,"The Redis client is now available in the ",(0,r.kt)("inlineCode",{parentName:"p"},"redis")," variable throughout the rest of the plugin execution cycle."),(0,r.kt)("h2",{id:"implementing-the-nominal-path"},"Implementing the nominal path"),(0,r.kt)("p",null,"In my previous software engineer life, I usually implemented the nominal path first. Afterward, I made the code more robust by managing error cases individually. This way, if I had to release at any point, I would still deliver business values - with warnings. I shall approach this mini-project the same way."),(0,r.kt)("p",null,"The pseudo-algorithm on the nominal path looks like the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"DO extract idempotency key from request\nDO look up value from Redis\nIF value doesn't exist\n  DO set key in Redis with empty value\nELSE\n  RETURN cached response\nDO forward to upstream\nDO store response in Redis\nRETURN response\n")),(0,r.kt)("p",null,"We need to map the logic to the phase I mentioned above. Two phases are available before the upstream, ",(0,r.kt)("inlineCode",{parentName:"p"},"rewrite")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"access"),"; three after, ",(0,r.kt)("inlineCode",{parentName:"p"},"header_filter"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"body_filter")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"log"),". The ",(0,r.kt)("inlineCode",{parentName:"p"},"access")," phase seemed obvious for work before, but I needed to figure out between the three others. I randomly chose the ",(0,r.kt)("inlineCode",{parentName:"p"},"body_filter"),", but I'm more than willing to listen to sensible arguments for other phases."),(0,r.kt)("p",null,"Note that I removed logs to make the code more readable. Error and informational logs are necessary to ease debugging production issues."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'function _M.access(conf, ctx)\n    local idempotency_key = core.request.header(ctx, "Idempotency-Key") --1\n    local redis_key = "idempotency#" .. idempotency_key     --2\n    local resp, err = redis:hgetall(redis_key)              --3\n    if not resp then\n        return\n    end\n    if next(resp) == nil then                               --4\n        local resp, err = redis:hset(redis_key, "request", true ) --4\n        if not resp then\n            return\n        end\n    else\n        local data = normalize_hgetall_result(resp)         --5\n        local response = core.json.decode(data["response"]) --6\n        local body = response["body"]                       --7\n        local status_code = response["status"]              --7\n        local headers = response["headers"]\n        for k, v in pairs(headers) do                       --7\n            core.response.set_header(k, v)\n        end\n        return core.response.exit(status_code, body)        --8\n    end\nend\n')),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Extract the idempotency key from the request"),(0,r.kt)("li",{parentName:"ol"},"Prefix the key so we avoid potential collisions"),(0,r.kt)("li",{parentName:"ol"},"Get the data set stored in Redis under the idempotency key"),(0,r.kt)("li",{parentName:"ol"},"If the key is not found, store it with a boolean mark"),(0,r.kt)("li",{parentName:"ol"},"Transform the data in a Lua table via a custom utility function"),(0,r.kt)("li",{parentName:"ol"},"The response is stored in JSON format to account for headers"),(0,r.kt)("li",{parentName:"ol"},"Reconstruct the response"),(0,r.kt)("li",{parentName:"ol"},"Return the reconstructed response to the client. Note the ",(0,r.kt)("inlineCode",{parentName:"li"},"return")," statement: APISIX skips the later lifecycle phases")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'function _M.body_filter(conf, ctx)\n    local idempotency_key = core.request.header(ctx, "Idempotency-Key") --1\n    local redis_key = "idempotency#" .. idempotency_key\n    if core.response then\n        local response = {                                  --2\n            status = ngx.status,\n            body = core.response.hold_body_chunk(ctx, true),\n            headers = ngx.resp.get_headers()\n        }\n        local redis_key = "idempotency#" .. redis_key\n        local resp, err = red:set(redis_key, "response", core.json.encode(response)) --3\n        if not resp then\n            return\n        end\n    end\nend\n')),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Extract the idempotency key from the request"),(0,r.kt)("li",{parentName:"ol"},"Arrange the different elements of a response in a Lua table"),(0,r.kt)("li",{parentName:"ol"},"Store the JSON-encoded response in a Redis set")),(0,r.kt)("p",null,"Tests reveal that it works as expected.\nTry:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"curl -i -X POST -H 'Idempotency-Key: A' localhost:9080/response-headers\\?freeform=hello\ncurl -i -H 'Idempotency-Key: B' localhost:9080/status/250\ncurl -i -H 'Idempotency-Key: C' -H 'foo: bar'  localhost:9080/status/250\n")),(0,r.kt)("p",null,"Also, try to reuse a mismatched idempotency key, ",(0,r.kt)("em",{parentName:"p"},"e.g."),", ",(0,r.kt)("inlineCode",{parentName:"p"},"A"),", for the third request. As we haven't implemented any error management yet, you'll get the cached response for another request. It's time to up our game."),(0,r.kt)("h2",{id:"implementing-error-paths"},"Implementing error paths"),(0,r.kt)("p",null,"The specification defines several error paths:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Idempotency-Key is missing"),(0,r.kt)("li",{parentName:"ul"},"Idempotency-Key is already used"),(0,r.kt)("li",{parentName:"ul"},"A request is outstanding for this Idempotency-Key")),(0,r.kt)("p",null,"Let's implement them one by one. First, let's check that the request has an idempotency key. Note that we can configure the plugin on a per-route basis, so if the route includes the plugin, we can conclude that it's mandatory."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'function _M.access(conf, ctx)\n    local idempotency_key = core.request.header(ctx, "Idempotency-Key")\n    if not idempotency_key then\n        return core.response.exit(400, "This operation is idempotent and it requires correct usage of Idempotency Key")\n    end\n    -- ...\n')),(0,r.kt)("p",null,"Just return the appropriate 400 if the key is missing. That one was easy."),(0,r.kt)("p",null,"Checking the reuse of an existing key for a different request is slightly more involved. We first need to store the request, or more precisely, the fingerprint of what constitutes a request. Two requests are the same if they have: the same method, the same path, the same body, and the same headers. Depending on your situation, the domain (and the port) might or may not be part of them. For my simple implementation, I'll leave it out."),(0,r.kt)("p",null,"There are several problems to solve. First, I didn't find an existing API to hash the ",(0,r.kt)("inlineCode",{parentName:"p"},"core.request")," object like there is in other languages I'm more familiar with, ",(0,r.kt)("em",{parentName:"p"},"e.g."),", Java's ",(0,r.kt)("inlineCode",{parentName:"p"},"Object.hash()"),". I decided to encode the object in JSON and hash the string. However, the existing ",(0,r.kt)("inlineCode",{parentName:"p"},"core.request")," has sub-elements that cannot be converted to JSON. I had to extract the parts mentioned above and convert the table."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},"local function hash_request(request, ctx)\n    local request = {                                       --1\n        method = core.request.get_method(),\n        uri = ctx.var.request_uri,\n        headers = core.request.headers(),\n        body = core.request.get_body()\n    }\n    local json = core.json.stably_encode(request)           --2\n    return ngx.encode_base64(json)                          --3\nend\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Create a table with only the relevant parts"),(0,r.kt)("li",{parentName:"ol"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"cjson")," library produces JSON whose members might be sorted differently across several calls. Hence, it results in different hashes. The ",(0,r.kt)("inlineCode",{parentName:"li"},"core.json.stably_encode")," fixes that issue."),(0,r.kt)("li",{parentName:"ol"},"Hash it")),(0,r.kt)("p",null,"Then, instead of storing a boolean when receiving the request, we store the resulting hash instead."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local hash = hash_request(core.request, ctx)\nif next(resp) == nil then\n    core.log.warn("No key found in Redis for Idempotency-Key, set it: ", redis_key)\n    local resp, err = redis:hset(redis_key, "request", hash)\n    if not resp then\n        core.log.error("Failed to set data in Redis: ", err)\n        return\n    end\nthen -- ...\n')),(0,r.kt)("p",null,"We read the hash stored under the idempotency key on the other branch. If they don't match, we exit with the relevant error code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'local data = normalize_hgetall_result(resp)\nlocal stored_hash = data["request"]\nif hash ~= stored_hash then\n    return core.response.exit(422, "This operation is idempotent and it requires correct usage of Idempotency Key. Idempotency Key MUST not be reused across different payloads of this operation.")\nend\n')),(0,r.kt)("p",null,"The final error management happens just afterward. Imagine the following scenario:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A request comes with idempotency key X"),(0,r.kt)("li",{parentName:"ol"},"The plugin fingerprints and stores the hash in Redis"),(0,r.kt)("li",{parentName:"ol"},"APISIX forwards the request to the upstream"),(0,r.kt)("li",{parentName:"ol"},"A duplicate request comes with the same idempotency key, X"),(0,r.kt)("li",{parentName:"ol"},"The plugin reads the data from Redis and finds no cached response")),(0,r.kt)("p",null,"The upstream didn't finish processing the request; hence, the first request hasn't yet reached the ",(0,r.kt)("inlineCode",{parentName:"p"},"body_filter")," phase."),(0,r.kt)("p",null,"We append the following code to the above snippet:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-lua"},'if not data["response"] then\n    return core.response.exit(409, " request with the same Idempotency-Key for the same operation is being processed or is outstanding.")\nend\n')),(0,r.kt)("p",null,"That's it."),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"In this post, I showed a simple implementation of the ",(0,r.kt)("inlineCode",{parentName:"p"},"Idempotency-Key")," header specification on Apache APISIX via a plugin. At this stage, it has room for improvement: automated tests, the ability to configure Redis on a per route basis, configure the domain/path to be part of the request, configure a Redis cluster instead of a single instance, use another K/V store, etc."),(0,r.kt)("p",null,"Yet, it does implement the specification and has the potential to evolve into a more production-grade implementation."),(0,r.kt)("p",null,"The complete source code for this post can be found on ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ajavageek/apisix-idempotency-plugin"},"GitHub"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"To go further:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://datatracker.ietf.org/doc/html/draft-ietf-httpapi-idempotency-key-header-04"},"Idempotency-Key HTTP Header Field")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://apisix.apache.org/blog/2024/04/04/fix-duplicate-api-requests/"},"Fixing duplicate API requests")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://apisix.apache.org/docs/apisix/plugin-develop/"},"Plugin Develop - APISIX website")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://api7.ai/blog/how-to-build-an-apache-apisix-plugin-from-0-to-1"},"How to Build an Apache APISIX Plugin From 0 to 1?"))))}u.isMDXComponent=!0}}]);