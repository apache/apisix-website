"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7411],{35318:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>h});var n=a(27378);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=p(a),h=r,d=m["".concat(l,".").concat(h)]||m[h]||c[h]||o;return a?n.createElement(d,i(i({ref:t},u),{},{components:a})):n.createElement(d,i({ref:t},u))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},13358:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var n=a(25773),r=(a(27378),a(35318));const o={title:"Apache APISIX loves Rust!",authors:[{name:"Nicolas Fr\xe4nkel",title:"Author",url:"https://github.com/nfrankel",image_url:"https://avatars.githubusercontent.com/u/752258"}],keywords:["API gateway","Apache APISIX","Rust","WebAssembly"],description:"This article shows the steps to perform to develop and deploy WebAssembly plugins from Rust.",tags:["Ecosystem"],image:"https://static.apiseven.com/2022/10/08/634113b161cce.png"},i=void 0,s={permalink:"/blog/2022/09/28/rust-loves-apisix",source:"@site/blog/2022/09/28/rust-loves-apisix.md",title:"Apache APISIX loves Rust!",description:"This article shows the steps to perform to develop and deploy WebAssembly plugins from Rust.",date:"2022-09-28T00:00:00.000Z",formattedDate:"September 28, 2022",tags:[{label:"Ecosystem",permalink:"/blog/tags/ecosystem"}],readingTime:5.48,truncated:!0,authors:[{name:"Nicolas Fr\xe4nkel",title:"Author",url:"https://github.com/nfrankel",image_url:"https://avatars.githubusercontent.com/u/752258",imageURL:"https://avatars.githubusercontent.com/u/752258"}],prevItem:{title:"Rewriting the Apache APISIX response-rewrite plugin in Rust",permalink:"/blog/2022/10/05/rust-apisix"},nextItem:{title:"Building event-driven API services using CQRS, API Gateway and Serverless",permalink:"/blog/2022/09/23/build-event-driven-api"}},l={authorsImageUrls:[void 0]},p=[{value:"A bit of context",id:"a-bit-of-context",children:[],level:2},{value:"Apache APISIX and proxy-wasm",id:"apache-apisix-and-proxy-wasm",children:[],level:2},{value:"Let&#39;s code!",id:"lets-code",children:[{value:"Preparing Rust for WebAssembly",id:"preparing-rust-for-webassembly",children:[],level:3},{value:"Setting up the project",id:"setting-up-the-project",children:[],level:3},{value:"The code itself",id:"the-code-itself",children:[],level:3}],level:2},{value:"Configuring Apache APISIX for WASM",id:"configuring-apache-apisix-for-wasm",children:[],level:2},{value:"Conclusion",id:"conclusion",children:[],level:2}],u={toc:p};function c(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"This article shows the steps to perform to develop and deploy WebAssembly plugins from Rust.")),(0,r.kt)("head",null,(0,r.kt)("link",{rel:"canonical",href:"https://blog.frankel.ch/rust-apisix/1/"})),(0,r.kt)("p",null,"Apache APISIX is built upon the shoulders of two giants:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://www.nginx.com/"},"NGINX"),", a widespread Open Source reverse-proxy"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://openresty.org/en/"},"OpenResty"),", a platform that allows scripting NGINX with the ",(0,r.kt)("a",{parentName:"li",href:"https://www.lua.org/"},"Lua")," programming language via ",(0,r.kt)("a",{parentName:"li",href:"https://luajit.org/"},"LuaJIT"))),(0,r.kt)("p",null,"This approach allows APISIX to provide out-of-the-box Lua plugins that should fit most business requirements. But it always comes a time when generic plugins don't fit your requirements. In this case, you can write your own Lua plugin."),(0,r.kt)("p",null,"However, if Lua is not part of your tech stack, ",(0,r.kt)("a",{parentName:"p",href:"https://blog.frankel.ch/on-learning-new-programming-language/"},"diving into a new ecosystem is a considerable investment"),". Therefore, Apache APISIX offers developers to write plugins in several other languages. In this post, I'd like to highlight how to write such a plugin with Rust."),(0,r.kt)("h2",{id:"a-bit-of-context"},"A bit of context"),(0,r.kt)("p",null,'Before I dive into the "how", let me first describe a bit of context surrounding the Rust integration in Apache APISIX. I believe it\'s a good story because it highlights the power of Open Source.'),(0,r.kt)("p",null,"It starts with the Envoy proxy."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Envoy is an open source edge and service proxy, designed for cloud-native applications"),(0,r.kt)("p",{parentName:"blockquote"},"-- ",(0,r.kt)("a",{parentName:"p",href:"https://www.envoyproxy.io/"},"https://www.envoyproxy.io/"))),(0,r.kt)("p",null,"Around 2019, Envoy's developers realized a simple truth. Since Envoy is a statically compiled binary, integrators who need to extend it must compile it from the modified source instead of using the official binary version. Issues range from supply chains more vulnerable to attacks to a longer drift when a new version is released. For end-users, whose core business is much further, it means having to hire specialized skills for this reason only."),(0,r.kt)("p",null,"The team considered to solve the issue with C++ extensions, but discarded this approach as neither ",(0,r.kt)("abbr",{title:"Application Programmer Interface"},"API"),"s nor ",(0,r.kt)("abbr",{title:"Application Binary Interface"},"ABI"),"s were stable. Instead, they chose to provide a stable WebAssembly-based ABI. If you're interested in a more detailed background, you can read the whole piece ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/proxy-wasm/spec/blob/master/docs/WebAssembly-in-Envoy.md"},"on GitHub"),"."),(0,r.kt)("p",null,"The specification is available on ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/proxy-wasm/spec"},"GitHub"),"."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Developers can create SDK for their tech stack"),(0,r.kt)("li",{parentName:"ul"},"Proxy and API Gateway providers can integrate ",(0,r.kt)("inlineCode",{parentName:"li"},"proxy-wasm")," in their product")),(0,r.kt)("h2",{id:"apache-apisix-and-proxy-wasm"},"Apache APISIX and proxy-wasm"),(0,r.kt)("p",null,"The Apache APISIX project decided to integrate ",(0,r.kt)("inlineCode",{parentName:"p"},"proxy-wasm")," into the product to benefit from the standardization effort. It also allows end-users to start with Envoy, or any other ",(0,r.kt)("inlineCode",{parentName:"p"},"proxy-wasm"),"-compatible reverse proxy, to migrate to Apache APISIX when necessary."),(0,r.kt)("p",null,"APISIX doesn't implement ",(0,r.kt)("inlineCode",{parentName:"p"},"proxy-wasm")," but integrates ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/api7/wasm-nginx-module"},"wasm-nginx-module"),". It's an Apache v2-licensed project provided by ",(0,r.kt)("a",{parentName:"p",href:"https://api7.ai/"},"api7.ai"),", one of the main contributors to Apache APISIX. As its name implies, integration is done at the NGINX level."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://static.apiseven.com/2022/09/30/architecture-diagram.svg",alt:"Apache APISIX and WebAssemby architecture overview"})),(0,r.kt)("h2",{id:"lets-code"},"Let's code!"),(0,r.kt)("p",null,"Now that we have explained how everything fits together, it's time to code."),(0,r.kt)("h3",{id:"preparing-rust-for-webassembly"},"Preparing Rust for WebAssembly"),(0,r.kt)("p",null,"Before developing the first line of code, we need to give Rust ",(0,r.kt)("abbr",{title:"WebAssembly"},"WASM")," compilation capabilities."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-shell"},"rustup target add wasm32-wasi\n")),(0,r.kt)("p",null,"It allows the Rust compiler to output WASM code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cargo build --target wasm32-wasi\n")),(0,r.kt)("p",null,"The WASM code is found in:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"target/wasm32-wasi/debug/sample.wasm")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"target/wasm32-wasi/release/sample.wasm")," (when compiled with the ",(0,r.kt)("inlineCode",{parentName:"li"},"--release")," flag)")),(0,r.kt)("h3",{id:"setting-up-the-project"},"Setting up the project"),(0,r.kt)("p",null,"The setup of the project is pretty straightforward:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"cargo new sample --lib\n")),(0,r.kt)("p",null,"The command creates a ",(0,r.kt)("inlineCode",{parentName:"p"},"lib")," project with the expected structure."),(0,r.kt)("h3",{id:"the-code-itself"},"The code itself"),(0,r.kt)("p",null,"Let me first say that the available documentation is pretty sparse. For example, ",(0,r.kt)("inlineCode",{parentName:"p"},"proxy-wasm"),"'s is limited to the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/proxy-wasm/spec/tree/master/abi-versions/vNEXT"},"methods' signature")," (think JavaDocs). Rust SDK is sample-based. However, one can get some information from the ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/proxy-wasm/proxy-wasm-cpp-sdk/blob/master/docs/wasm_filter.md"},"C++ SDK"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"WASM module is running in a stack-based virtual machine and its memory is isolated from the host environment. All interactions between host and WASM module are through functions and callbacks wrapped by context object."),(0,r.kt)("p",{parentName:"blockquote"},"At bootstrap time, a root context is created. The root context has the same lifetime as the VM/runtime instance and acts as a target for any interactions which happen at initial setup. It is also used for interactions that outlive a request."),(0,r.kt)("p",{parentName:"blockquote"},"At request time, a context with incremental is created for each stream. Stream context has the same lifetime as the stream itself and acts as a target for interactions that are local to that stream.")),(0,r.kt)("p",null,"The Rust code maps to the same abstractions."),(0,r.kt)("p",null,(0,r.kt)("img",{parentName:"p",src:"https://static.apiseven.com/2022/09/30/struct-diagram.svg",alt:"Rust's 'structure diagram'"})),(0,r.kt)("p",null,"Here's the code for a ",(0,r.kt)("strong",{parentName:"p"},"very")," simple plugin that logs to prove that it's invoked:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},'use log::warn;\nuse proxy_wasm::traits::{Context, HttpContext};\nuse proxy_wasm::types::{Action, LogLevel};\n\nproxy_wasm::main! {{\n    proxy_wasm::set_log_level(LogLevel::Trace);                                          //1\n    proxy_wasm::set_http_context(|_, _| -> Box<dyn HttpContext> { Box::new(HttpCall) }); //2\n}}\n\nstruct HttpCall;\n\nimpl Context for HttpCall {}                                                             //3\n\nimpl HttpContext for HttpCall {                                                          //4\n    fn on_http_request_headers(&mut self, _: usize, _: bool) -> Action {                 //5\n        warn!("on_http_request_headers");                                                //6\n        Action::Continue\n    }\n}\n')),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Set the log level to Apache APISIX's default"),(0,r.kt)("li",{parentName:"ol"},"Set the HTTP context to create for ",(0,r.kt)("em",{parentName:"li"},"each")," request"),(0,r.kt)("li",{parentName:"ol"},"Need to implement ",(0,r.kt)("inlineCode",{parentName:"li"},"Context"),". By default, ",(0,r.kt)("strong",{parentName:"li"},"all")," functions are implemented in ",(0,r.kt)("inlineCode",{parentName:"li"},"Context"),", so implementation is not mandatory"),(0,r.kt)("li",{parentName:"ol"},"Likewise for ",(0,r.kt)("inlineCode",{parentName:"li"},"HttpContext")),(0,r.kt)("li",{parentName:"ol"},"Implement the function. Functions in ",(0,r.kt)("inlineCode",{parentName:"li"},"HttpContext")," refer to a phase in the ABI lifecycle when headers are decoded. It should return an ",(0,r.kt)("inlineCode",{parentName:"li"},"Action"),", whose value is either ",(0,r.kt)("inlineCode",{parentName:"li"},"Continue")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"Pause"),"."),(0,r.kt)("li",{parentName:"ol"},"Log - finally")),(0,r.kt)("p",null,"After generating the WebAssembly code (see above), we have to configure Apache APISIX."),(0,r.kt)("h2",{id:"configuring-apache-apisix-for-wasm"},"Configuring Apache APISIX for WASM"),(0,r.kt)("p",null,"Apache APISIX's ",(0,r.kt)("a",{parentName:"p",href:"https://apisix.apache.org/docs/apisix/wasm/"},"documentation")," is geared toward Go. Still, since both Go and Rust generate WebAssembly, we can reuse most of it."),(0,r.kt)("p",null,"We need to declare each WASM plugin:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"wasm:\n  plugins:\n    - name: sample\n      priority: 7999\n      file: /opt/apisix/wasm/sample.wasm\n")),(0,r.kt)("p",null,"Then, we can use the plugin like any other:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},'routes:\n  - uri: /*\n    upstream:\n      type: roundrobin\n      nodes:\n        "httpbin.org:80": 1\n    plugins:\n      sample:                                #1\n       conf: "dummy"                         #2\n#END\n')),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Plugin name"),(0,r.kt)("li",{parentName:"ol"},"At the moment, the ",(0,r.kt)("inlineCode",{parentName:"li"},"conf")," attribute is mandatory and must be non-empty on the Apache APISIX validation side, even though we don't configure anything on the Rust side")),(0,r.kt)("p",null,"At this point, we can ping the endpoint:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"curl localhost:9080\n")),(0,r.kt)("p",null,"The result is as expected:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'rust-wasm-plugin-apisix-1  | 2022/09/21 13:43:14 [warn] 44#44: *286 on_http_request_headers, client: 192.168.128.1, server: _, request: "GET / HTTP/1.1", host: "localhost:9080"\n')),(0,r.kt)("h2",{id:"conclusion"},"Conclusion"),(0,r.kt)("p",null,"In this post, I described the history behind the ",(0,r.kt)("inlineCode",{parentName:"p"},"proxy-wasm")," and how Apache APISIX integrates it via the WASM Nginx module. I explained how to set up your Rust local environment to generate WebAssembly. Finally, I created a dummy plugin and deployed it to Apache APISIX."),(0,r.kt)("p",null,"In the next post, we'll beef up the plugin to provide valuable capabilities."),(0,r.kt)("p",null,"The source code is available on ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/ajavageek/apisix-rust-plugin"},"GitHub"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"To go further:")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/proxy-wasm/spec"},"proxy-wasm spec")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/api7/wasm-nginx-module"},"WASM Nginx module")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://github.com/proxy-wasm/proxy-wasm-rust-sdk"},"WebAssembly for Proxies (Rust SDK)")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://apisix.apache.org/docs/apisix/wasm/"},"Apache APISIX WASM"))))}c.isMDXComponent=!0}}]);