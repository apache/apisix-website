"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[15747],{35318:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>h});var n=a(27378);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},u=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),m=p(a),h=o,d=m["".concat(s,".").concat(h)]||m[h]||c[h]||r;return a?n.createElement(d,i(i({ref:t},u),{},{components:a})):n.createElement(d,i({ref:t},u))}));function h(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=a.length,i=new Array(r);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var p=2;p<r;p++)i[p]=a[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},77467:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var n=a(25773),o=(a(27378),a(35318));const r={title:"A poor man's API",authors:[{name:"Nicolas Fr\xe4nkel",title:"Author",url:"https://github.com/nfrankel",image_url:"https://avatars.githubusercontent.com/u/752258"}],keywords:["API","PostgreSQL","PostgREST","no code","MVP"],description:"Creating a full-fledged API requires resources, both time and money. You need to think about the model, the design, the REST principles, etc., without writing a single line of code. Most of the time, you don't know whether it's worth it: you'd like to offer a Minimum Viable Product and iterate from there. I want to show how you can achieve it without writing a single line of code.",tags:["Ecosystem"],image:"https://static.apiseven.com/2022/11/28/63841cb4ad10a.png"},i=void 0,l={permalink:"/blog/2022/11/23/poor-man-api",source:"@site/blog/2022/11/23/poor-man-api.md",title:"A poor man's API",description:"Creating a full-fledged API requires resources, both time and money. You need to think about the model, the design, the REST principles, etc., without writing a single line of code. Most of the time, you don't know whether it's worth it: you'd like to offer a Minimum Viable Product and iterate from there. I want to show how you can achieve it without writing a single line of code.",date:"2022-11-23T00:00:00.000Z",formattedDate:"November 23, 2022",tags:[{label:"Ecosystem",permalink:"/blog/tags/ecosystem"}],readingTime:7.985,truncated:!0,authors:[{name:"Nicolas Fr\xe4nkel",title:"Author",url:"https://github.com/nfrankel",image_url:"https://avatars.githubusercontent.com/u/752258",imageURL:"https://avatars.githubusercontent.com/u/752258"}],prevItem:{title:"How to choose the right API Style and Technology",permalink:"/blog/2022/12/06/choose-the-right-api-style-technology"},nextItem:{title:"Geo-routing with Apache APISIX",permalink:"/blog/2022/11/09/georouting-apisix"}},s={authorsImageUrls:[void 0]},p=[{value:"The solution",id:"the-solution",children:[],level:2},{value:"Improving the solution",id:"improving-the-solution",children:[],level:2},{value:"DDoS protection",id:"ddos-protection",children:[],level:2},{value:"Per-route authorization",id:"per-route-authorization",children:[],level:2},{value:"Monitoring",id:"monitoring",children:[],level:2},{value:"Conclusion",id:"conclusion",children:[],level:2}],u={toc:p};function c(e){let{components:t,...a}=e;return(0,o.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Creating a full-fledged API requires resources, both time and money. You need to think about the model, the design, the REST principles, etc., without writing a single line of code. Most of the time, you don't know whether it's worth it: you'd like to offer a Minimum Viable Product and iterate from there. I want to show how you can achieve it without writing a single line of code.")),(0,o.kt)("head",null,(0,o.kt)("link",{rel:"canonical",href:"https://blog.frankel.ch/poor-man-api/"})),(0,o.kt)("h2",{id:"the-solution"},"The solution"),(0,o.kt)("p",null,"The main requirement of the solution is to use the ",(0,o.kt)("a",{parentName:"p",href:"https://www.postgresql.org/"},"PostgreSQL database"),". It's a well-established Open Source SQL database."),(0,o.kt)("p",null,"Instead of writing our REST API, we use the PostgREST component:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"PostgREST is a standalone web server that turns your PostgreSQL database directly into a RESTful API. The structural constraints and permissions in the database determine the API endpoints and operations."),(0,o.kt)("p",{parentName:"blockquote"},"-- ",(0,o.kt)("a",{parentName:"p",href:"https://postgrest.org/"},"PostgREST"))),(0,o.kt)("p",null,"Let's apply it to a simple use case. Here's a ",(0,o.kt)("inlineCode",{parentName:"p"},"product")," table that I want to expose via a CRUD API:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://blog.frankel.ch/assets/generated/poor-man-api/table.svg",alt:"Product table"})),(0,o.kt)("p",null,"Note that you can find the whole source code on ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ajavageek/poor-man-api"},"GitHub")," to follow along."),(0,o.kt)("p",null,"PostgREST's ",(0,o.kt)("a",{parentName:"p",href:"https://postgrest.org/en/stable/tutorials/tut0.html"},"Getting Started guide")," is pretty complete and works out of the box. Yet, I didn't find any ready-made Docker image, so I created my own:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-dockerfile"},"FROM debian:bookworm-slim                                                   #1\n\nARG POSTGREST_VERSION=v10.1.1                                               #2\nARG POSTGREST_FILE=postgrest-$POSTGREST_VERSION-linux-static-x64.tar.xz     #2\n\nRUN mkdir postgrest\n\nWORKDIR postgrest\n\nADD https://github.com/PostgREST/postgrest/releases/download/$POSTGREST_VERSION/$POSTGREST_FILE \\\n    .                                                                       #3\n\nRUN apt-get update && \\\n    apt-get install -y libpq-dev xz-utils && \\\n    tar xvf $POSTGREST_FILE && \\\n    rm $POSTGREST_FILE                                                      #4\n")),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Start from the latest Debian"),(0,o.kt)("li",{parentName:"ol"},"Parameterize the build"),(0,o.kt)("li",{parentName:"ol"},"Get the archive"),(0,o.kt)("li",{parentName:"ol"},"Install dependencies and unarchive")),(0,o.kt)("p",null,"The Docker image contains a ",(0,o.kt)("inlineCode",{parentName:"p"},"postgrest")," executable in the ",(0,o.kt)("inlineCode",{parentName:"p"},"/postgrest"),' folder. We can "deploy" the architecture via Docker Compose:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'version: "3"\nservices:\n  postgrest:\n    build: ./postgrest                                   #1\n    volumes:\n      - ./postgrest/product.conf:/etc/product.conf:ro    #2\n    ports:\n      - "3000:3000"\n    entrypoint: ["/postgrest/postgrest"]                 #3\n    command: ["/etc/product.conf"]                       #4\n    depends_on:\n      - postgres\n  postgres:\n    image: postgres:15-alpine\n    environment:\n      POSTGRES_PASSWORD: "root"\n    volumes:\n      - ./postgres:/docker-entrypoint-initdb.d:ro       #5\n')),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Build the above ",(0,o.kt)("inlineCode",{parentName:"li"},"Dockerfile")),(0,o.kt)("li",{parentName:"ol"},"Share the configuration file"),(0,o.kt)("li",{parentName:"ol"},"Run the ",(0,o.kt)("inlineCode",{parentName:"li"},"postgrest")," executable"),(0,o.kt)("li",{parentName:"ol"},"With the configuration file"),(0,o.kt)("li",{parentName:"ol"},"Initialize the schema, the permissions, and the data")),(0,o.kt)("p",null,"At this point, we can query the ",(0,o.kt)("inlineCode",{parentName:"p"},"product")," table:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"curl localhost:3000/product\n")),(0,o.kt)("p",null,"We immediately get the results:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'[{"id":1,"name":"Stickers pack","description":"A pack of rad stickers to display on your laptop or wherever you feel like. Show your love for Apache APISIX","price":0.49,"hero":false},\n {"id":2,"name":"Lapel pin","description":"With this \\"Powered by Apache APISIX\\" lapel pin, support your favorite API Gateway and let everybody know about it.","price":1.49,"hero":false},\n {"id":3,"name":"Tee-Shirt","description":"The classic geek product! At a conference, at home, at work, this tee-shirt will be your best friend.","price":9.99,"hero":true}]\n')),(0,o.kt)("p",null,"That was a quick win!"),(0,o.kt)("h2",{id:"improving-the-solution"},"Improving the solution"),(0,o.kt)("p",null,"Though the solution works, it has a lot of room for improvement. For example, the database user cannot change the data, but everybody can actually access it. It might not be a big issue for product-related data, but what about medical data?"),(0,o.kt)("p",null,"The PostgREST documentation is aware of it and explicitly advises using a reverse proxy:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"PostgREST is a fast way to construct a RESTful API. Its default behavior is great for scaffolding in development. When it\u2019s time to go to production it works great too, as long as you take precautions. PostgREST is a small sharp tool that focuses on performing the API-to-database mapping. We rely on a reverse proxy like Nginx for additional safeguards."),(0,o.kt)("p",{parentName:"blockquote"},"-- ",(0,o.kt)("a",{parentName:"p",href:"https://postgrest.org/en/stable/admin.html"},"Hardening PostgREST"))),(0,o.kt)("p",null,"Instead of nginx, we would benefit from a full-fledged API Gateway: enters ",(0,o.kt)("a",{parentName:"p",href:"https://apisix.apache.org/"},"Apache APISIX"),". We shall add it to our Docker Compose:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'version: "3"\nservices:\n  apisix:\n    image: apache/apisix:2.15.0-alpine                              #1\n    volumes:\n      - ./apisix/config.yml:/usr/local/apisix/conf/config.yaml:ro\n    ports:\n      - "9080:9080"\n    restart: always\n    depends_on:\n      - etcd\n      - postgrest\n  etcd:\n    image: bitnami/etcd:3.5.2                                       #2\n    environment:\n      ETCD_ENABLE_V2: "true"\n      ALLOW_NONE_AUTHENTICATION: "yes"\n      ETCD_ADVERTISE_CLIENT_URLS: "http://0.0.0.0:2397"\n      ETCD_LISTEN_CLIENT_URLS: "http://0.0.0.0:2397"\n')),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Use Apache APISIX"),(0,o.kt)("li",{parentName:"ol"},"APISIX stores its configuration in ",(0,o.kt)("a",{parentName:"li",href:"https://etcd.io/"},"etcd"))),(0,o.kt)("p",null,"We shall first configure Apache APISIX to proxy calls to ",(0,o.kt)("inlineCode",{parentName:"p"},"postgrest"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'curl http://apisix:9080/apisix/admin/upstreams/1 -H \'X-API-KEY: 123xyz\' -X PUT -d \' #1-2\n{\n  "type": "roundrobin",\n  "nodes": {\n    "postgrest:3000": 1                                                             #1-3\n  }\n}\'\n\ncurl http://apisix:9080/apisix/admin/routes/1 -H \'X-API-KEY: 123xyz\' -X PUT -d \'    #4\n{\n  "uri": "/*",\n  "upstream_id": 1\n}\'\n')),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Should be run in one of the Docker nodes, so use the Docker image's name. Alternatively, use ",(0,o.kt)("inlineCode",{parentName:"li"},"localhost")," but be sure to expose the ports"),(0,o.kt)("li",{parentName:"ol"},"Create a reusable ",(0,o.kt)("em",{parentName:"li"},"upstream")),(0,o.kt)("li",{parentName:"ol"},"Point to the PostgREST node"),(0,o.kt)("li",{parentName:"ol"},"Create a ",(0,o.kt)("em",{parentName:"li"},"route")," to the created ",(0,o.kt)("em",{parentName:"li"},"upstream"))),(0,o.kt)("p",null,"We can now query the endpoint via APISIX:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"curl localhost:9080/product\n")),(0,o.kt)("p",null,"It returns the same result as above."),(0,o.kt)("h2",{id:"ddos-protection"},"DDoS protection"),(0,o.kt)("p",null,"We haven't added anything, but we're ready to start the work. Let's first protect our API from ",(0,o.kt)("abbr",{title:"Distributed Denial of Service"},"DDoS")," attacks. Apache APISIX is designed around a plugin architecture. To protect from DDoS, we shall use a plugin. We can set plugins on a specific ",(0,o.kt)("em",{parentName:"p"},"route")," when it's created or on every ",(0,o.kt)("em",{parentName:"p"},"route"),"; in the latter case, it's a ",(0,o.kt)("em",{parentName:"p"},"global rule"),". We want to protect every route by default, so we shall use one."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'curl http://apisix:9080/apisix/admin/global_rules/1 -H \'X-API-KEY: 123xyz\' -X PUT -d \'\n{\n  "plugins": {\n    "limit-count": {                 #1\n      "count": 1,                    #2\n      "time_window": 5,              #2\n      "rejected_code": 429           #3\n    }\n  }\n}\'\n')),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"limit-count")," limits the number of calls in a time window"),(0,o.kt)("li",{parentName:"ol"},"Limit to 1 call per 5 seconds; it's for demo purposes"),(0,o.kt)("li",{parentName:"ol"},"Return ",(0,o.kt)("inlineCode",{parentName:"li"},"429 Too Many Requests"),"; the default is ",(0,o.kt)("inlineCode",{parentName:"li"},"503"))),(0,o.kt)("p",null,"Now, if we execute too many requests, Apache APISIX protects the upstream:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"curl localhost:9080/product\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-html"},"<html>\n<head><title>429 Too Many Requests</title></head>\n<body>\n<center><h1>429 Too Many Requests</h1></center>\n<hr><center>openresty</center>\n</body>\n</html>\n")),(0,o.kt)("h2",{id:"per-route-authorization"},"Per-route authorization"),(0,o.kt)("p",null,"PostgREST also offers an Open API endpoint at the root. We thus have two routes: ",(0,o.kt)("inlineCode",{parentName:"p"},"/")," for the Open API spec and ",(0,o.kt)("inlineCode",{parentName:"p"},"/product")," for the products. Suppose we want to disallow unauthorized people to access our data: Regular users can access products, while admin users can access both the Open API spec ",(0,o.kt)("strong",{parentName:"p"},"and")," products."),(0,o.kt)("p",null,"APISIX offers several ",(0,o.kt)("a",{parentName:"p",href:"https://apisix.apache.org/plugins/#authentication"},"authentication methods"),". We will use the simplest one possible, ",(0,o.kt)("a",{parentName:"p",href:"https://apisix.apache.org/docs/apisix/plugins/key-auth/"},"key-auth"),". It relies on the ",(0,o.kt)("a",{parentName:"p",href:"https://apisix.apache.org/docs/apisix/terminology/consumer/"},"Consumer")," abstraction. ",(0,o.kt)("inlineCode",{parentName:"p"},"key-auth")," requires a specific header: the plugin does a reverse lookup on the value and finds the consumer whose key corresponds."),(0,o.kt)("p",null,"Here's how to create a consumer:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'curl http://apisix:9080/apisix/admin/consumers -H \'X-API-KEY: 123xyz\' -X PUT -d \'    #1\n{\n  "username": "admin",                                                               #2\n  "plugins": {\n    "key-auth": {\n      "key": "admin"                                                                 #3\n    }\n  }\n}\'\n')),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Create a new consumer"),(0,o.kt)("li",{parentName:"ol"},"Consumer's name"),(0,o.kt)("li",{parentName:"ol"},"Consumer's key value")),(0,o.kt)("p",null,"We do the same with consumer ",(0,o.kt)("inlineCode",{parentName:"p"},"user")," and key ",(0,o.kt)("inlineCode",{parentName:"p"},"user"),". Now, we can create a dedicated route and configure it so that only requests from ",(0,o.kt)("inlineCode",{parentName:"p"},"admin")," pass through:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'curl http://apisix:9080/apisix/admin/routes -H \'X-API-KEY: 123xyz\' -X POST -d \' #1\n{\n  "uri": "/",\n  "upstream_id": 1,\n  "plugins": {\n    "key-auth": {},                                                             #2\n    "consumer-restriction": {                                                   #2\n      "whitelist": [ "admin" ]                                                  #3\n    }\n  }\n}\'\n')),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Create a new route"),(0,o.kt)("li",{parentName:"ol"},"Use the ",(0,o.kt)("inlineCode",{parentName:"li"},"key-auth")," and ",(0,o.kt)("inlineCode",{parentName:"li"},"consumer-restriction")," plugins"),(0,o.kt)("li",{parentName:"ol"},"Only ",(0,o.kt)("inlineCode",{parentName:"li"},"admin"),"-authenticated requests can call the route")),(0,o.kt)("p",null,"Let's try the following:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"curl localhost:9080\n")),(0,o.kt)("p",null,"It doesn't work as we are not authenticated via an API key header."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{"message":"Missing API key found in request"}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'curl -H "apikey: user" localhost:9080\n')),(0,o.kt)("p",null,"It doesn't work as we are authenticated as ",(0,o.kt)("inlineCode",{parentName:"p"},"user"),", but the route is not authorized for ",(0,o.kt)("inlineCode",{parentName:"p"},"user")," but for ",(0,o.kt)("inlineCode",{parentName:"p"},"admin"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{"message":"The consumer_name is forbidden."}\n')),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},'curl -H "apikey: admin" localhost:9080\n')),(0,o.kt)("p",null,"This time, it returns the Open API spec as expected."),(0,o.kt)("h2",{id:"monitoring"},"Monitoring"),(0,o.kt)("p",null,"A much-undervalued feature of any software system is monitoring. As soon as you deploy any component in production, you must monitor its health. Nowadays, many services are available to monitor. We will use ",(0,o.kt)("a",{parentName:"p",href:"https://prometheus.io/"},"Prometheus")," as it's Open Source, battle-proven, and widespread. To display the data, we will rely on ",(0,o.kt)("a",{parentName:"p",href:"https://grafana.com/"},"Grafana")," for the same reasons. Let's add the components to the Docker Compose file:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'version: "3"\nservices:\n  prometheus:\n    image: prom/prometheus:v2.40.1                                    #1\n    volumes:\n      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml    #2\n    depends_on:\n      - apisix\n  grafana:\n    image: grafana/grafana:8.5.15                                     #3\n    volumes:\n      - ./grafana/provisioning:/etc/grafana/provisioning              #4\n      - ./grafana/dashboards:/var/lib/grafana/dashboards              #4\n      - ./grafana/config/grafana.ini:/etc/grafana/grafana.ini         #4-5\n    ports:\n      - "3001:3001"\n    depends_on:\n      - prometheus\n')),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Prometheus image"),(0,o.kt)("li",{parentName:"ol"},"Prometheus configuration to scrape Apache APISIX. See the full file ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/ajavageek/poor-man-api/blob/master/prometheus/prometheus.yml"},"here")),(0,o.kt)("li",{parentName:"ol"},"Grafana image"),(0,o.kt)("li",{parentName:"ol"},"Grafana configuration. Most of it comes from the configuration ",(0,o.kt)("a",{parentName:"li",href:"https://github.com/apache/apisix/blob/master/docs/assets/other/json/apisix-grafana-dashboard.json"},"provided")," by APISIX."),(0,o.kt)("li",{parentName:"ol"},"Change the default port from ",(0,o.kt)("inlineCode",{parentName:"li"},"3000")," to ",(0,o.kt)("inlineCode",{parentName:"li"},"3001")," to avoid conflict with the PostgREST service")),(0,o.kt)("p",null,"Once the monitoring infrastructure is in place, we only need to instruct APISIX to provide the data in a format that Prometheus expects. We can achieve it through configuration and a new global rule:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-yaml"},'plugin_attr:\n  prometheus:\n    export_addr:\n      ip: "0.0.0.0"             #1\n      port: 9091                #2\n')),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"Bind to any address"),(0,o.kt)("li",{parentName:"ol"},"Bind to port ",(0,o.kt)("inlineCode",{parentName:"li"},"9091"),". Prometheus metrics are available on ",(0,o.kt)("inlineCode",{parentName:"li"},"http://apisix:9091/apisix/prometheus/metrics")," on the Docker network")),(0,o.kt)("p",null,"We can create the global rule:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"curl http://apisix:9080/apisix/admin/global_rules/2 -H 'X-API-KEY: 123xyz' -X PUT -d '\n{\n  \"plugins\": {\n    \"prometheus\": {}\n  }\n}'\n")),(0,o.kt)("p",null,"Send a couple of queries and open the Grafana dashboard. It should look similar to this:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://static.apiseven.com/uploads/2023/06/08/VU9tQ69R_grafana.jpeg",alt:"Grafana dashboard"})),(0,o.kt)("h2",{id:"conclusion"},"Conclusion"),(0,o.kt)("p",null,"Creating a full-fledged REST(ful) API is a huge investment. One can quickly test a simple API by exposing one's database in a CRUD API via PostgREST. However, such an architecture is not fit for production usage."),(0,o.kt)("p",null,"To fix it, you need to set a fa\xe7ade in front of PostgREST, a reverse proxy, or even better, an API Gateway. Apache APISIX offers a wide range of features, from authorization to monitoring. With it, you can quickly validate your API requirements at a low cost."),(0,o.kt)("p",null,"The icing on the cake: when you've validated the requirements, you can keep the existing fa\xe7ade and replace PostgREST with your custom-developed API."),(0,o.kt)("p",null,"The source code is available on ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ajavageek/poor-man-api"},"GitHub"),"."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"To go further:")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://postgrest.org/"},"PostgREST")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://apisix.apache.org/docs/apisix/getting-started/"},"Getting started with Apache APISIX")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://apisix.apache.org/plugins/"},"Apache APISIX plugins"))))}c.isMDXComponent=!0}}]);