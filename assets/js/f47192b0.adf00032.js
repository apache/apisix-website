"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[49171],{35318:(e,t,a)=>{a.d(t,{Zo:()=>h,kt:()=>d});var r=a(27378);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},s=Object.keys(e);for(r=0;r<s.length;r++)a=s[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)a=s[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var c=r.createContext({}),l=function(e){var t=r.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},h=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,s=e.originalType,c=e.parentName,h=i(e,["components","mdxType","originalType","parentName"]),p=l(a),d=n,g=p["".concat(c,".").concat(d)]||p[d]||u[d]||s;return a?r.createElement(g,o(o({ref:t},h),{},{components:a})):r.createElement(g,o({ref:t},h))}));function d(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var s=a.length,o=new Array(s);o[0]=p;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:n,o[1]=i;for(var l=2;l<s;l++)o[l]=a[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}p.displayName="MDXCreateElement"},14297:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var r=a(25773),n=(a(27378),a(35318));const s={title:"Does etcd 3 Support HTTP Access Perfectly?",slug:"2021/06/30/etcd3-support-http-access-perfectly",author:"Zexuan Luo",authorURL:"https://github.com/spacewander",authorImageURL:"https://avatars.githubusercontent.com/u/4161644?v=4",keywords:["Apache APISIX","etcd","HTTP","gRPC"],Description:"When Apache APISIX synchronizes etcd data in full, if there is enough configuration, the data size that can be read by a single request, which is the default limit of gRPC, is reached.",tags:["Ecosystem"]},o=void 0,i={permalink:"/blog/2021/06/30/etcd3-support-http-access-perfectly",source:"@site/blog/2021/06/30/etcd3-support-HTTP-access-perfectly.md",title:"Does etcd 3 Support HTTP Access Perfectly?",description:"It has been 8 months since the release of Apache APISIX version 2.0 last October. In the course of practice, we have also discovered some issues with etcd's HTTP API that interoperate with the gRPC API. In fact, having a gRPC-gateway does not mean that HTTP access is perfectly supported, there are some nuances here.",date:"2021-06-30T00:00:00.000Z",formattedDate:"June 30, 2021",tags:[{label:"Ecosystem",permalink:"/blog/tags/ecosystem"}],readingTime:5.005,truncated:!0,authors:[{name:"Zexuan Luo",url:"https://github.com/spacewander",imageURL:"https://avatars.githubusercontent.com/u/4161644?v=4"}],prevItem:{title:"Apache APISIX has over 200 contributors in GitHub main repo! ",permalink:"/blog/2021/07/06/celebrate-200-contributors"},nextItem:{title:"Release Apache APISIX 2.7.0",permalink:"/blog/2021/06/29/release-apache-apisix-2.7"}},c={authorsImageUrls:[void 0]},l=[{value:"Breaking the Default Restrictions of gRPC",id:"breaking-the-default-restrictions-of-grpc",children:[],level:2},{value:"Interesting Usage of Server-side Certificates",id:"interesting-usage-of-server-side-certificates",children:[],level:2},{value:"Summary",id:"summary",children:[],level:2}],h={toc:l};function u(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,r.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"It has been 8 months since the release of Apache APISIX version 2.0 last October. In the course of practice, we have also discovered some issues with etcd's HTTP API that interoperate with the gRPC API. In fact, having a gRPC-gateway does not mean that HTTP access is perfectly supported, there are some nuances here.")),(0,n.kt)("p",null,"After etcd was upgraded to version 3.x, the protocol of its external API was switched from normal HTTP1 to gRPC. etcd proxied HTTP1 requests through gRPC-gateway to access the new gRPC API in the form of gRPC for those special groups that cannot use gRPC. (Since HTTP1 is too awkward to pronounce, the following is simplified to HTTP, which corresponds to gRPC. Please don\u2019t get hung up on the fact that gRPC is also an HTTP request.)"),(0,n.kt)("p",null,"When Apache APISIX started using etcd, we used the etcd v2 API, and since Apache APISIX version 2.0, we have upgraded our dependency on etcd to 3.x. Since there is no gRPC library in the Lua ecosystem, etcd\u2019s HTTP compatibility has helped us a lot, so we don\u2019t have to go through a lot of effort to patch This was a big help, so we didn\u2019t have to go to a lot of trouble to fill in the gaps."),(0,n.kt)("p",null,"It has been 8 months since the release of Apache APISIX version 2.0 last October. In the course of practice, we have also discovered some issues with etcd\u2019s HTTP API that interoperates with the gRPC API. In fact, having a gRPC-gateway does not mean that HTTP access is perfectly supported, there are some nuances here."),(0,n.kt)("h2",{id:"breaking-the-default-restrictions-of-grpc"},"Breaking the Default Restrictions of gRPC"),(0,n.kt)("p",null,"Just a few days ago, etcd released version v3.5.0. This release solves a problem that has been bothering us for a long time."),(0,n.kt)("p",null,"Unlike HTTP, gRPC limits the size of data that can be read in one request by default. This limit is called \u201cMaxCallRecvMsgSize\u201d and defaults to 4MiB. When Apache APISIX fully synchronizes etcd data, this limit can be triggered if configured enough and the error \u201cgrpc: received message larger than max\u201d."),(0,n.kt)("p",null,"Miraculously, if you use etcdctl to access it, there is no problem at all. This is because this limit can be set dynamically when establishing a connection with the gRPC server. etcdctl sets this limit to a large integer, which is equivalent to removing this limit."),(0,n.kt)("p",null,"Since many users have encountered the same problem, we have discussed countermeasures.\nOne idea was to use incremental synchronization to simulate full synchronization, which has two drawbacks."),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"It is complicated to implement and requires a lot of code changes."),(0,n.kt)("li",{parentName:"ol"},"It would extend the time required for synchronization.")),(0,n.kt)("p",null,"Another idea is to modify etcd. If you can remove the restrictions in etcdctl, why not treat gRPC-gateway the same way? The same change can be made to gRPC-gateway.\nWe\u2019ve adopted the second option, and have given etcd a PR: ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/etcd-io/etcd/pull/13077"},"PR #13077"),"."),(0,n.kt)("p",null,(0,n.kt)("img",{parentName:"p",src:"https://static.apiseven.com/202108/1639465584634-26435c89-3e1c-4fb9-b094-057fce0f769d.png",alt:"2021-06-30-1"})),(0,n.kt)("p",null,"The latest release of v3.5.0 includes this change that we contributed. If you encounter \u201cgrpc: received message larger than max\u201d, you may want to try this version. This change has also been back-ported to the 3.4 branch by the etcd developers, and the next release of the 3.4 branch will carry this change as well."),(0,n.kt)("p",null,"This incident also shows that gRPC-gateway is not foolproof. Even with it, there is no guarantee that HTTP access will have the same experience as gRPC access."),(0,n.kt)("h2",{id:"interesting-usage-of-server-side-certificates"},"Interesting Usage of Server-side Certificates"),(0,n.kt)("p",null,"After Apache APISIX added support for etcd mTLS, some users reported that they have been unable to complete the checksum, while accessing with etcdctl was successful. After talking to the user, I decided to take his certificate and reproduce it."),(0,n.kt)("p",null,"During the replication process, I noticed this error in the etcd log:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-text"},'2021-06-09 11:10:13.022735 I | embed: rejected connection from "127.0.0.1:50898" (error "tls: failed to verify client\'s certificate: x509: certificate specifies an incompatible key usage", ServerName "")\nWARNING: 2021/06/09 11:10:13 grpc: addrConn.createTransport failed to connect to {127.0.0.1:12379 0 }. Err :connection error: desc = "transport: authentication handshake failed: remote error: tls: bad certificate". Reconnecting...\n')),(0,n.kt)("p",null,"The \u201cbad certificate\u201d error message looks at first glance like it is because we sent the wrong client certificate to etcd. But if you look closely, you will see that this error is reported inside the gRPC server."),(0,n.kt)("p",null,"The gRPC-gateway acts as a proxy inside etcd, turning outside HTTP requests into gRPC requests that the gRPC server can handle."),(0,n.kt)("p",null,"The general architecture is as follows:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-text"},"etcdctl ----\x3e gRPC server\nApache APISIX ---\x3e gRPC-gateway ---\x3e gRPC server\n")),(0,n.kt)("p",null,"Why does etcdctl connect directly to the gRPC server, but not with a gRPC-gateway in between?"),(0,n.kt)("p",null,"It turns out that when etcd enables client-side certificate validation, a client-side certificate is required to connect to the gRPC server using the gRPC-gateway. Guess where this certificate comes from?"),(0,n.kt)("p",null,"etcd uses the configured server-side certificate directly as the client-side certificate here."),(0,n.kt)("p",null,"A certificate that provides both authentication on the server side and identity on the client side doesn\u2019t seem to be a problem. Unless server auth expansion is enabled on the certificate, but client auth is not enabled. Execute the following command on the faulty certificate:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-shell"},"openssl x509 -text -noout -in /tmp/bad.crt\n")),(0,n.kt)("p",null,"You will see output like this:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-text"},"X509v3 extensions:\nX509v3 Key Usage: critical\nDigital Signature, Key Encipherment\nX509v3 Extended Key Usage:\nTLS Web Server Authentication\n")),(0,n.kt)("p",null,"Note the \u201cTLS Web Server Authentication\u201d here, if we change it to \u201cTLS Web Server Authentication, TLS Web Client Authentication\u201d or without this extension, there will be no problem."),(0,n.kt)("p",null,"There is also an issue about this problem on etcd\u2019s repository: Issue ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/etcd-io/etcd/issues/9785"},"#9785"),"."),(0,n.kt)("p",null,(0,n.kt)("img",{parentName:"p",src:"https://static.apiseven.com/202108/1639465662863-30bc4fa9-8b7c-47d9-a73e-810bd690a588.png",alt:"2021-06-30-2"})),(0,n.kt)("h2",{id:"summary"},"Summary"),(0,n.kt)("p",null,"Although we have listed a few minor issues above, etcd\u2019s support for HTTP access is still a very useful feature."),(0,n.kt)("p",null,"Thanks to the users of Apache APISIX, we have a large user base to find these details of etcd. As a large user of etcd, we will continue to communicate with the etcd developers for many years to come."))}u.isMDXComponent=!0}}]);