"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5505],{35318:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>m});var r=a(27378);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var s=r.createContext({}),p=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},c=function(e){var t=p(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=p(a),m=n,d=h["".concat(s,".").concat(m)]||h[m]||u[m]||i;return a?r.createElement(d,o(o({ref:t},c),{},{components:a})):r.createElement(d,o({ref:t},c))}));function m(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,o=new Array(i);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,o[1]=l;for(var p=2;p<i;p++)o[p]=a[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}h.displayName="MDXCreateElement"},59849:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>p});var r=a(25773),n=(a(27378),a(35318));const i={title:"Free tier API with Apache APISIX",authors:[{name:"Nicolas Fr\xe4nkel",title:"Author",url:"https://github.com/nfrankel",image_url:"https://avatars.githubusercontent.com/u/752258"}],keywords:["APISIX","Free tier","Rate limiting","Consumer"],description:"Lots of service providers offer a free tier of their service. The idea is to let you kick their service's tires freely. If you need to go above the free tier at any point, you'll likely stay on the service and pay. In this day and age, most services are online and accessible via an API. Today, we will implement a free tier with Apache APISIX.\n",tags:["Ecosystem"],image:"https://static.apiseven.com/uploads/2024/08/03/9WL5vdEC_beer-2439237.jpg"},o=void 0,l={permalink:"/blog/2024/08/01/free-tier-api-apisix",source:"@site/blog/2024/08/01/free-tier-api-apisix.md",title:"Free tier API with Apache APISIX",description:"Lots of service providers offer a free tier of their service. The idea is to let you kick their service's tires freely. If you need to go above the free tier at any point, you'll likely stay on the service and pay. In this day and age, most services are online and accessible via an API. Today, we will implement a free tier with Apache APISIX.\n",date:"2024-08-01T00:00:00.000Z",formattedDate:"August 1, 2024",tags:[{label:"Ecosystem",permalink:"/blog/tags/ecosystem"}],readingTime:4.145,truncated:!0,authors:[{name:"Nicolas Fr\xe4nkel",title:"Author",url:"https://github.com/nfrankel",image_url:"https://avatars.githubusercontent.com/u/752258",imageURL:"https://avatars.githubusercontent.com/u/752258"}],prevItem:{title:"Release Apache APISIX 3.10.0",permalink:"/blog/2024/08/14/release-apache-apisix-3.10.0"},nextItem:{title:"Monthly Report (July 01 - July 31)",permalink:"/blog/2024/07/31/monthly-report"}},s={authorsImageUrls:[void 0]},p=[{value:"A naive approach",id:"a-naive-approach",children:[],level:2},{value:"APISIX route matching",id:"apisix-route-matching",children:[],level:2},{value:"Implementing free tier with matching rules",id:"implementing-free-tier-with-matching-rules",children:[],level:2},{value:"Conclusion",id:"conclusion",children:[],level:2}],c={toc:p};function u(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,r.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("head",null,(0,n.kt)("link",{rel:"canonical",href:"https://blog.frankel.ch/free-tier-api-apisix/"})),(0,n.kt)("blockquote",null,(0,n.kt)("p",{parentName:"blockquote"},"Lots of service providers offer a free tier of their service. The idea is to let you kick their service's tires freely. If you need to go above the free tier at any point, you'll likely stay on the service and pay. In this day and age, most services are online and accessible via an API. Today, we will implement a free tier with ",(0,n.kt)("a",{parentName:"p",href:"https://apisix.apache.org/"},"Apache APISIX"),".")),(0,n.kt)("h2",{id:"a-naive-approach"},"A naive approach"),(0,n.kt)("p",null,"I implemented a free tier in my post ",(0,n.kt)("a",{parentName:"p",href:"https://blog.frankel.ch/evolve-apis/#know-your-users"},"Evolving your RESTful APIs, a step-by-step approach"),", albeit in a very naive way. I copy-pasted the ",(0,n.kt)("a",{parentName:"p",href:"https://apisix.apache.org/docs/apisix/plugins/limit-count/"},"limit-count")," plugin and added my required logic."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-lua"},'function _M.access(conf, ctx)\n    core.log.info("ver: ", ctx.conf_version)\n\n    -- no limit if the request is authenticated\n    local key = core.request.header(ctx, conf.header)                               #1\n    if key then\n        local consumer_conf = consumer_mod.plugin("key-auth")                       #2\n        if consumer_conf then\n            local consumers = lrucache("consumers_key", consumer_conf.conf_version, #3\n                    create_consume_cache, consumer_conf)\n            local consumer = consumers[key]                                         #4\n            if consumer then                                                        #5\n                return\n            end\n        end\n    end\n-- rest of the logic\n')),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Get the configured request header value"),(0,n.kt)("li",{parentName:"ol"},"Get the consumer's ",(0,n.kt)("inlineCode",{parentName:"li"},"key-auth")," configuration"),(0,n.kt)("li",{parentName:"ol"},"Get consumers"),(0,n.kt)("li",{parentName:"ol"},"Get the consumer with the passed API key if they exist"),(0,n.kt)("li",{parentName:"ol"},"If they exist, bypass the rate limiting logic")),(0,n.kt)("p",null,"The downside of this approach is that the code is now my own. It has evolved since I copied it, and I'm stuck with the version I copied. We can do better, with the help of the ",(0,n.kt)("inlineCode",{parentName:"p"},"vars")," parameter on routes."),(0,n.kt)("h2",{id:"apisix-route-matching"},"APISIX route matching"),(0,n.kt)("p",null,"APISIX delegates its matching rule to a ",(0,n.kt)("a",{parentName:"p",href:"https://apisix.apache.org/docs/apisix/terminology/router/"},"router"),".\nStandard matching parameters include:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"The URI"),(0,n.kt)("li",{parentName:"ul"},"The HTTP method. By default, all methods match."),(0,n.kt)("li",{parentName:"ul"},"The host"),(0,n.kt)("li",{parentName:"ul"},"The remote address")),(0,n.kt)("p",null,"Most users do match on the URI; a small minority use HTTP methods and the host. However, they are not the only matching parameters. Knowing the rest will bring you into the world of advanced users of APISIX."),(0,n.kt)("p",null,"Let's take a simple example, header-based API versioning. You'd need actually to match a specific HTTP request header. I've already described how to do it ",(0,n.kt)("a",{parentName:"p",href:"https://blog.frankel.ch/api-versioning/"},"previously"),". In essence, ",(0,n.kt)("inlineCode",{parentName:"p"},"vars")," is an additional matching criterion that allows the evaluation of APISIX and nginx variables."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-yaml"},'routes:\n  - uri: /*\n    upstream_id: 1\n    vars: [[ "http_accept", "==", "vnd.ch.frankel.myservice.v1+json" ]]\n')),(0,n.kt)("p",null,"The above route will match if, and only if, the HTTP ",(0,n.kt)("inlineCode",{parentName:"p"},"Accept")," header is equal to ",(0,n.kt)("inlineCode",{parentName:"p"},"vnd.ch.frankel.myservice.v1+json"),". You can find the complete list of supported operators in the ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/api7/lua-resty-expr"},"lua-resty-expr")," project."),(0,n.kt)("p",null,"APISIX matches routes in a non-specified order by default. If URIs are ",(0,n.kt)("em",{parentName:"p"},"disjointed"),", that's not an issue."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-yaml"},'routes:\n  - uri: /*\n    upstream_id: 1\n    vars: [[ "http_accept", "==", "vnd.ch.frankel.myservice.v1+json" ]]\n  - uri: /*\n    upstream_id: 2\n    vars: [[ "http_accept", "==", "vnd.ch.frankel.myservice.v2+json" ]]\n')),(0,n.kt)("p",null,"Problems arise when URIs are somehow not disjointed. For example, imagine I want to set a default route for unversioned calls."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-yaml"},'routes:\n  - uri: /*\n    upstream_id: 1\n    vars: [[ "http_accept", "==", "vnd.ch.frankel.myservice.v1+json" ]]\n  - uri: /*\n    upstream_id: 2\n    vars: [[ "http_accept", "==", "vnd.ch.frankel.myservice.v2+json" ]]\n  - uri: /*\n    upstream_id: 1\n')),(0,n.kt)("p",null,"We need the third route to be evaluated last. If it's evaluated first, it will match all requests, regardless of their HTTP headers. APISIX offers the ",(0,n.kt)("inlineCode",{parentName:"p"},"priority")," parameter to order route evaluation. By default, a route's priority is 0. Let's use ",(0,n.kt)("inlineCode",{parentName:"p"},"priority")," to implement the versioning correctly:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-yaml"},'routes:\n  - uri: /*\n    upstream_id: 1\n    vars: [[ "http_accept", "==", "vnd.ch.frankel.myservice.v1+json" ]]\n    priority: 10                                              #1\n  - uri: /*\n    upstream_id: 2\n    vars: [[ "http_accept", "==", "vnd.ch.frankel.myservice.v2+json" ]]\n    priority: 10                                              #1\n  - uri: /*\n    upstream_id: 1\n')),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Evaluated first. The order is not relevant since the URIs are disjointed.")),(0,n.kt)("h2",{id:"implementing-free-tier-with-matching-rules"},"Implementing free tier with matching rules"),(0,n.kt)("p",null,"We are now ready to implement our free tier with matching rules."),(0,n.kt)("p",null,"The first route to be evaluated should be the one with authentication and no rate limit:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-yaml"},'routes:\n  - uri: /get\n    upstream_id: 1\n    vars: [[ "http_apikey", "~~", ".*"]]                      #1\n    plugins:\n      key-auth: ~                                             #2\n    priority: 10                                              #3\n')),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Match if the request has an HTTP header named ",(0,n.kt)("inlineCode",{parentName:"li"},"apikey")),(0,n.kt)("li",{parentName:"ol"},"Authenticate the request"),(0,n.kt)("li",{parentName:"ol"},"Evaluate first")),(0,n.kt)("p",null,"The other route is evaluated afterward."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-yaml"},"  - uri: /get\n    upstream_id: 1\n    plugins:\n      limit-count:                                            #1\n        count: 1\n        time_window: 60\n        rejected_code: 429\n")),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Rate limit this route")),(0,n.kt)("p",null,"When you configure APISIX with the above snippets, and it receives a request to ",(0,n.kt)("inlineCode",{parentName:"p"},"/get"),", it tries to match the first route ",(0,n.kt)("em",{parentName:"p"},"only")," if it has an ",(0,n.kt)("inlineCode",{parentName:"p"},"apikey")," request header:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"If it has one:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"The ",(0,n.kt)("inlineCode",{parentName:"li"},"key-auth")," plugin kicks in"),(0,n.kt)("li",{parentName:"ul"},"If it succeeds, APISIX forwars the request to the upstream"),(0,n.kt)("li",{parentName:"ul"},"If it fails, APISIX returns a 403 HTTP status code"))),(0,n.kt)("li",{parentName:"ol"},"If it has no such request header, it matches the second route with a rate limit.")),(0,n.kt)("h2",{id:"conclusion"},"Conclusion"),(0,n.kt)("p",null,"A free tier is a must for any API service provider worth its salt. In this post, I've explained how to configure such free tier with Apache APISIX."),(0,n.kt)("p",null,"The complete source code for this post can be found on ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/ajavageek/free-tier-apisix"},"GitHub"),"."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"To go further:")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://apisix.apache.org/docs/apisix/terminology/consumer/"},"Consumer")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://apisix.apache.org/docs/apisix/plugins/limit-count/"},"limit-count plugin")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://apisix.apache.org/docs/apisix/router-radixtree/"},"router-radixtree")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/api7/lua-resty-expr"},"lua-resty-expr"))))}u.isMDXComponent=!0}}]);